{"version":3,"sources":["helpers/GLTFLoader.ts","Head.tsx","App.tsx","index.tsx"],"names":["GLTFLoader","manager","dracoLoader","ktx2Loader","meshoptDecoder","pluginCallbacks","register","parser","GLTFMaterialsClearcoatExtension","GLTFTextureBasisUExtension","GLTFTextureWebPExtension","GLTFMaterialsTransmissionExtension","GLTFLightsExtension","GLTFMeshoptCompression","url","onLoad","onProgress","onError","resourcePath","scope","this","path","LoaderUtils","extractUrlBase","itemStart","_onError","e","console","error","itemError","itemEnd","loader","FileLoader","setPath","setResponseType","setRequestHeader","requestHeader","setWithCredentials","withCredentials","load","data","parse","gltf","Error","callback","indexOf","push","splice","content","extensions","plugins","decodeText","Uint8Array","BINARY_EXTENSION_HEADER_MAGIC","EXTENSIONS","KHR_BINARY_GLTF","GLTFBinaryExtension","json","JSON","undefined","asset","version","GLTFParser","crossOrigin","fileLoader","i","length","plugin","name","extensionsUsed","extensionName","extensionsRequired","KHR_MATERIALS_UNLIT","GLTFMaterialsUnlitExtension","KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS","GLTFMaterialsPbrSpecularGlossinessExtension","KHR_DRACO_MESH_COMPRESSION","GLTFDracoMeshCompressionExtension","KHR_TEXTURE_TRANSFORM","GLTFTextureTransformExtension","KHR_MESH_QUANTIZATION","GLTFMeshQuantizationExtension","warn","setExtensions","setPlugins","Loader","GLTFRegistry","objects","get","key","add","object","remove","removeAll","KHR_LIGHTS_PUNCTUAL","KHR_MATERIALS_CLEARCOAT","KHR_MATERIALS_TRANSMISSION","KHR_TEXTURE_BASISU","EXT_TEXTURE_WEBP","EXT_MESHOPT_COMPRESSION","cache","refs","uses","nodeDefs","nodes","nodeIndex","nodeLength","nodeDef","light","_addNodeRef","lightIndex","cacheKey","dependency","lightNode","lightDef","lights","color","Color","fromArray","range","type","DirectionalLight","target","position","set","PointLight","distance","SpotLight","spot","innerConeAngle","outerConeAngle","Math","PI","angle","penumbra","decay","intensity","createUniqueName","Promise","resolve","self","_loadLight","then","_getNodeRef","MeshBasicMaterial","materialParams","materialDef","pending","opacity","metallicRoughness","pbrMetallicRoughness","Array","isArray","baseColorFactor","array","baseColorTexture","assignTexture","all","materialIndex","materials","MeshPhysicalMaterial","extension","clearcoatFactor","clearcoat","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughness","clearcoatRoughnessTexture","clearcoatNormalTexture","scale","clearcoatNormalScale","Vector2","transmissionFactor","transmission","transmissionTexture","textureIndex","textureDef","textures","source","images","options","loadTextureImage","isSupported","textureLoader","uri","handler","getHandler","detectSupport","loadTexture","image","Image","src","onload","onerror","height","index","bufferView","bufferViews","extensionDef","buffer","getDependency","decoder","supported","ready","res","byteOffset","byteLength","count","stride","byteStride","result","ArrayBuffer","decodeGltfBuffer","mode","filter","BINARY_EXTENSION_CHUNK_TYPES","body","header","headerView","DataView","magic","slice","getUint32","chunkContentsLength","chunkView","chunkIndex","chunkLength","chunkType","contentArray","preload","primitive","bufferViewIndex","gltfAttributeMap","attributes","threeAttributeMap","attributeNormalizedMap","attributeTypeMap","attributeName","threeAttributeName","ATTRIBUTES","toLowerCase","accessorDef","accessors","componentType","WEBGL_COMPONENT_TYPES","normalized","decodeDracoFile","geometry","attribute","texture","transform","texCoord","offset","rotation","clone","repeat","needsUpdate","GLTFMeshStandardSGMaterial","params","isGLTFSpecularGlossinessMaterial","_extraUniforms","specularMap","specular","glossinessMap","glossiness","specularMapParsFragmentChunk","join","glossinessMapParsFragmentChunk","specularMapFragmentChunk","glossinessMapFragmentChunk","lightPhysicalFragmentChunk","uniforms","value","setHex","onBeforeCompile","shader","uniformName","fragmentShader","replace","Object","defineProperties","v","defines","USE_SPECULARMAP","USE_GLOSSINESSMAP","USE_UV","metalness","roughness","metalnessMap","roughnessMap","setValues","copy","MeshStandardMaterial","specularGlossinessParams","pbrSpecularGlossiness","diffuseFactor","diffuseTexture","emissive","glossinessFactor","specularFactor","specularGlossinessTexture","specGlossMapDef","material","fog","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","TangentSpaceNormalMap","normalScale","displacementMap","displacementScale","displacementBias","alphaMap","envMap","envMapIntensity","refractionRatio","GLTFCubicSplineInterpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","beforeStart_","afterEnd_","interpolate_","values","valueSize","Interpolant","prototype","copySampleValue_","i1","t0","t","t1","stride2","stride3","td","p","pp","ppp","offset1","offset0","s2","s3","s0","s1","p0","m0","p1","m1","WEBGL_CONSTANTS","5120","Int8Array","5121","5122","Int16Array","5123","Uint16Array","5125","Uint32Array","5126","Float32Array","WEBGL_FILTERS","9728","NearestFilter","9729","LinearFilter","9984","NearestMipmapNearestFilter","9985","LinearMipmapNearestFilter","9986","NearestMipmapLinearFilter","9987","LinearMipmapLinearFilter","WEBGL_WRAPPINGS","33071","ClampToEdgeWrapping","33648","MirroredRepeatWrapping","10497","RepeatWrapping","WEBGL_TYPE_SIZES","SCALAR","VEC2","VEC3","VEC4","MAT2","MAT3","MAT4","POSITION","NORMAL","TANGENT","TEXCOORD_0","TEXCOORD_1","COLOR_0","WEIGHTS_0","JOINTS_0","PATH_PROPERTIES","translation","weights","INTERPOLATION","CUBICSPLINE","LINEAR","InterpolateLinear","STEP","InterpolateDiscrete","ALPHA_MODES","resolveURL","test","addUnknownExtensionsToUserData","knownExtensions","objectDef","userData","gltfExtensions","assignExtrasToUserData","gltfDef","extras","assign","updateMorphTargets","mesh","meshDef","il","morphTargetInfluences","targetNames","morphTargetDictionary","createPrimitiveKey","primitiveDef","dracoExtension","indices","createAttributesKey","attributesKey","keys","sort","getNormalizedComponentScale","constructor","associations","primitiveCache","meshCache","cameraCache","lightCache","textureCache","nodeNamesUsed","URL","webkitURL","Map","createImageBitmap","navigator","userAgent","ImageBitmapLoader","TextureLoader","setCrossOrigin","_invokeAll","ext","_markDefs","beforeRoot","getDependencies","dependencies","scene","scenes","animations","cameras","afterRoot","catch","skinDefs","skins","meshDefs","meshes","skinIndex","skinLength","joints","isBone","skin","isSkinnedMesh","camera","ref","func","unshift","loadScene","loadNode","_invokeOne","loadMesh","loadAccessor","loadBufferView","loadBuffer","loadMaterial","loadSkin","loadAnimation","loadCamera","defs","def","bufferIndex","bufferDef","buffers","reject","bufferViewDef","accessorIndex","sparse","pendingBufferViews","bufferAttribute","itemSize","TypedArray","elementBytes","BYTES_PER_ELEMENT","itemBytes","ibSlice","floor","ibCacheKey","ib","InterleavedBuffer","InterleavedBufferAttribute","BufferAttribute","itemSizeIndices","TypedArrayIndices","byteOffsetIndices","byteOffsetValues","sparseIndices","sparseValues","setX","setY","setZ","setW","sampler","sourceURI","isObjectURL","hasAlpha","isJPEG","search","mimeType","colorType","getUint8","blob","Blob","createObjectURL","promise","isImageBitmapLoader","imageBitmap","Texture","revokeObjectURL","flipY","format","RGBFormat","samplers","magFilter","minFilter","wrapS","wrapT","mapName","mapDef","gltfReference","extendTexture","useVertexTangents","tangent","useVertexColors","useFlatShading","normal","useMorphTargets","morphAttributes","useMorphNormals","isPoints","uuid","pointsMaterial","PointsMaterial","Material","call","sizeAttenuation","isLine","lineMaterial","LineBasicMaterial","cachedMaterial","vertexColors","flatShading","morphTargets","morphNormals","vertexTangents","y","uv2","uv","setAttribute","materialType","materialExtensions","sgExtension","getMaterialType","extendParams","kmuExtension","metallicFactor","roughnessFactor","metallicRoughnessTexture","extendMaterialParams","doubleSided","side","DoubleSide","alphaMode","transparent","depthWrite","alphaTest","alphaCutoff","normalTexture","occlusionTexture","strength","emissiveFactor","emissiveTexture","createMaterial","encoding","sRGBEncoding","originalName","sanitizedName","PropertyBinding","sanitizeNodeName","primitives","createDracoPrimitive","decodePrimitive","addPrimitiveAttributes","cached","geometryPromise","BufferGeometry","meshIndex","depthTest","FrontSide","loadGeometries","results","geometries","SkinnedMesh","Mesh","skinWeight","normalizeSkinWeights","toTrianglesDrawMode","TriangleStripDrawMode","TriangleFanDrawMode","LineSegments","Line","LineLoop","Points","assignFinalMaterial","group","Group","cameraIndex","cameraDef","PerspectiveCamera","MathUtils","radToDeg","yfov","aspectRatio","znear","zfar","OrthographicCamera","xmag","ymag","skinDef","skinEntry","inverseBindMatrices","accessor","animationIndex","animationDef","pendingNodes","pendingInputAccessors","pendingOutputAccessors","pendingSamplers","pendingTargets","channels","channel","node","id","input","parameters","output","inputAccessors","outputAccessors","targets","tracks","inputAccessor","outputAccessor","updateMatrix","matrixAutoUpdate","TypedKeyframeTrack","NumberKeyframeTrack","QuaternionKeyframeTrack","VectorKeyframeTrack","targetName","interpolation","traverse","isMesh","outputArray","scaled","j","jl","track","createInterpolant","times","getValueSize","isInterpolantFactoryMethodGLTFCubicSpline","AnimationClip","o","nodeName","meshPromise","createNodeMesh","createNodeAttachment","forEach","Bone","Object3D","matrix","Matrix4","applyMatrix4","quaternion","sceneIndex","sceneDef","nodeIds","buildNodeHierachy","nodeId","parentObject","pendingJoints","jointNodes","bones","boneInverses","jointNode","mat","bind","Skeleton","matrixWorld","children","child","assignAttributeAccessor","gltfAttributeName","setIndex","box","Box3","min","max","Vector3","boxScale","multiplyScalar","maxDisplacement","vector","abs","expandByVector","boundingBox","sphere","Sphere","getCenter","center","radius","distanceTo","boundingSphere","computeBounds","hasMorphPosition","hasMorphNormal","pendingPositionAccessors","pendingNormalAccessors","pendingAccessor","morphPositions","morphTargetsRelative","addMorphTargets","drawMode","getIndex","getAttribute","numberOfTriangles","newIndices","getX","newGeometry","Head","container","renderer","spotLight","mouseX","mouseY","targetX","targetY","windowHalfX","window","innerWidth","windowHalfY","innerHeight","onWindowResize","setSize","aspect","updateProjectionMatrix","onDocumentMouseMove","event","clientX","clientY","document","getElementById","THREE","z","background","castShadow","shadow","mapSize","width","near","far","fov","bias","mapHeight","LoadingManager","receiveShadow","createScene","setPixelRatio","devicePixelRatio","appendChild","domElement","shadowMap","enabled","outputEncoding","addEventListener","init","animate","requestAnimationFrame","x","setScalar","render","App","useEffect","className","ReactDOM"],"mappings":"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","file":"static/js/main.78c4bdaf.chunk.js","sourcesContent":["import {\r\n  AnimationClip,\r\n  Bone,\r\n  Box3,\r\n  BufferAttribute,\r\n  BufferGeometry,\r\n  ClampToEdgeWrapping,\r\n  Color,\r\n  DirectionalLight,\r\n  DoubleSide,\r\n  FileLoader,\r\n  FrontSide,\r\n  Group,\r\n  ImageBitmapLoader,\r\n  InterleavedBuffer,\r\n  InterleavedBufferAttribute,\r\n  Interpolant,\r\n  InterpolateDiscrete,\r\n  InterpolateLinear,\r\n  Line,\r\n  LineBasicMaterial,\r\n  LineLoop,\r\n  LineSegments,\r\n  LinearFilter,\r\n  LinearMipmapLinearFilter,\r\n  LinearMipmapNearestFilter,\r\n  Loader,\r\n  LoaderUtils,\r\n  Material,\r\n  MathUtils,\r\n  Matrix4,\r\n  Mesh,\r\n  MeshBasicMaterial,\r\n  MeshPhysicalMaterial,\r\n  MeshStandardMaterial,\r\n  MirroredRepeatWrapping,\r\n  NearestFilter,\r\n  NearestMipmapLinearFilter,\r\n  NearestMipmapNearestFilter,\r\n  NumberKeyframeTrack,\r\n  Object3D,\r\n  OrthographicCamera,\r\n  PerspectiveCamera,\r\n  PointLight,\r\n  Points,\r\n  PointsMaterial,\r\n  PropertyBinding,\r\n  QuaternionKeyframeTrack,\r\n  RGBFormat,\r\n  RepeatWrapping,\r\n  Skeleton,\r\n  SkinnedMesh,\r\n  Sphere,\r\n  SpotLight,\r\n  TangentSpaceNormalMap,\r\n  Texture,\r\n  TextureLoader,\r\n  TriangleFanDrawMode,\r\n  TriangleStripDrawMode,\r\n  Vector2,\r\n  Vector3,\r\n  VectorKeyframeTrack,\r\n  sRGBEncoding,\r\n  LoadingManager,\r\n} from \"three\";\r\n\r\nclass GLTFLoader extends Loader {\r\n  dracoLoader: any;\r\n  ktx2Loader: any;\r\n  meshoptDecoder: any;\r\n  pluginCallbacks: any[];\r\n  constructor(manager: LoadingManager) {\r\n    super(manager);\r\n\r\n    this.dracoLoader = null;\r\n    this.ktx2Loader = null;\r\n    this.meshoptDecoder = null;\r\n\r\n    this.pluginCallbacks = [];\r\n\r\n    this.register(function (parser) {\r\n      return new GLTFMaterialsClearcoatExtension(parser);\r\n    });\r\n\r\n    this.register(function (parser) {\r\n      return new GLTFTextureBasisUExtension(parser);\r\n    });\r\n\r\n    this.register(function (parser) {\r\n      return new GLTFTextureWebPExtension(parser);\r\n    });\r\n\r\n    this.register(function (parser) {\r\n      return new GLTFMaterialsTransmissionExtension(parser);\r\n    });\r\n\r\n    this.register(function (parser) {\r\n      return new GLTFLightsExtension(parser);\r\n    });\r\n\r\n    this.register(function (parser) {\r\n      return new GLTFMeshoptCompression(parser);\r\n    });\r\n  }\r\n\r\n  load(url, onLoad, onProgress, onError) {\r\n    const scope = this;\r\n\r\n    let resourcePath;\r\n\r\n    if (this.resourcePath !== \"\") {\r\n      resourcePath = this.resourcePath;\r\n    } else if (this.path !== \"\") {\r\n      resourcePath = this.path;\r\n    } else {\r\n      resourcePath = LoaderUtils.extractUrlBase(url);\r\n    }\r\n\r\n    // Tells the LoadingManager to track an extra item, which resolves after\r\n    // the model is fully loaded. This means the count of items loaded will\r\n    // be incorrect, but ensures manager.onLoad() does not fire early.\r\n    this.manager.itemStart(url);\r\n\r\n    const _onError = function (e) {\r\n      if (onError) {\r\n        onError(e);\r\n      } else {\r\n        console.error(e);\r\n      }\r\n\r\n      scope.manager.itemError(url);\r\n      scope.manager.itemEnd(url);\r\n    };\r\n\r\n    const loader = new FileLoader(this.manager);\r\n\r\n    loader.setPath(this.path);\r\n    loader.setResponseType(\"arraybuffer\");\r\n    loader.setRequestHeader(this.requestHeader);\r\n    loader.setWithCredentials(this.withCredentials);\r\n\r\n    loader.load(\r\n      url,\r\n      function (data) {\r\n        try {\r\n          scope.parse(\r\n            data,\r\n            resourcePath,\r\n            function (gltf) {\r\n              onLoad(gltf);\r\n\r\n              scope.manager.itemEnd(url);\r\n            },\r\n            _onError\r\n          );\r\n        } catch (e) {\r\n          _onError(e);\r\n        }\r\n      },\r\n      onProgress,\r\n      _onError\r\n    );\r\n  }\r\n\r\n  setDRACOLoader(dracoLoader) {\r\n    this.dracoLoader = dracoLoader;\r\n    return this;\r\n  }\r\n\r\n  setDDSLoader() {\r\n    throw new Error(\r\n      'THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".'\r\n    );\r\n  }\r\n\r\n  setKTX2Loader(ktx2Loader) {\r\n    this.ktx2Loader = ktx2Loader;\r\n    return this;\r\n  }\r\n\r\n  setMeshoptDecoder(meshoptDecoder) {\r\n    this.meshoptDecoder = meshoptDecoder;\r\n    return this;\r\n  }\r\n\r\n  register(callback) {\r\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\r\n      this.pluginCallbacks.push(callback);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  unregister(callback) {\r\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\r\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  parse(data, path, onLoad, onError) {\r\n    let content;\r\n    const extensions = {};\r\n    const plugins = {};\r\n\r\n    if (typeof data === \"string\") {\r\n      content = data;\r\n    } else {\r\n      const magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));\r\n\r\n      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\r\n        try {\r\n          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(\r\n            data\r\n          );\r\n        } catch (error) {\r\n          if (onError) onError(error);\r\n          return;\r\n        }\r\n\r\n        content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;\r\n      } else {\r\n        content = LoaderUtils.decodeText(new Uint8Array(data));\r\n      }\r\n    }\r\n\r\n    const json = JSON.parse(content);\r\n\r\n    if (json.asset === undefined || json.asset.version[0] < 2) {\r\n      if (onError)\r\n        onError(\r\n          new Error(\r\n            \"THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.\"\r\n          )\r\n        );\r\n      return;\r\n    }\r\n\r\n    const parser = new GLTFParser(json, {\r\n      path: path || this.resourcePath || \"\",\r\n      crossOrigin: this.crossOrigin,\r\n      requestHeader: this.requestHeader,\r\n      manager: this.manager,\r\n      ktx2Loader: this.ktx2Loader,\r\n      meshoptDecoder: this.meshoptDecoder,\r\n    });\r\n\r\n    parser.fileLoader.setRequestHeader(this.requestHeader);\r\n\r\n    for (let i = 0; i < this.pluginCallbacks.length; i++) {\r\n      const plugin = this.pluginCallbacks[i](parser);\r\n      plugins[plugin.name] = plugin;\r\n\r\n      // Workaround to avoid determining as unknown extension\r\n      // in addUnknownExtensionsToUserData().\r\n      // Remove this workaround if we move all the existing\r\n      // extension handlers to plugin system\r\n      extensions[plugin.name] = true;\r\n    }\r\n\r\n    if (json.extensionsUsed) {\r\n      for (let i = 0; i < json.extensionsUsed.length; ++i) {\r\n        const extensionName = json.extensionsUsed[i];\r\n        const extensionsRequired = json.extensionsRequired || [];\r\n\r\n        switch (extensionName) {\r\n          case EXTENSIONS.KHR_MATERIALS_UNLIT:\r\n            extensions[extensionName] = new GLTFMaterialsUnlitExtension();\r\n            break;\r\n\r\n          case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\r\n            extensions[\r\n              extensionName\r\n            ] = new GLTFMaterialsPbrSpecularGlossinessExtension();\r\n            break;\r\n\r\n          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\r\n            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(\r\n              json,\r\n              this.dracoLoader\r\n            );\r\n            break;\r\n\r\n          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\r\n            extensions[extensionName] = new GLTFTextureTransformExtension();\r\n            break;\r\n\r\n          case EXTENSIONS.KHR_MESH_QUANTIZATION:\r\n            extensions[extensionName] = new GLTFMeshQuantizationExtension();\r\n            break;\r\n\r\n          default:\r\n            if (\r\n              extensionsRequired.indexOf(extensionName) >= 0 &&\r\n              plugins[extensionName] === undefined\r\n            ) {\r\n              console.warn(\r\n                'THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".'\r\n              );\r\n            }\r\n        }\r\n      }\r\n    }\r\n\r\n    parser.setExtensions(extensions);\r\n    parser.setPlugins(plugins);\r\n    parser.parse(onLoad, onError);\r\n  }\r\n}\r\n\r\n/* GLTFREGISTRY */\r\n\r\nfunction GLTFRegistry() {\r\n  let objects = {};\r\n\r\n  return {\r\n    get: function (key) {\r\n      return objects[key];\r\n    },\r\n\r\n    add: function (key, object) {\r\n      objects[key] = object;\r\n    },\r\n\r\n    remove: function (key) {\r\n      delete objects[key];\r\n    },\r\n\r\n    removeAll: function () {\r\n      objects = {};\r\n    },\r\n  };\r\n}\r\n\r\n/*********************************/\r\n/********** EXTENSIONS ***********/\r\n/*********************************/\r\n\r\nconst EXTENSIONS = {\r\n  KHR_BINARY_GLTF: \"KHR_binary_glTF\",\r\n  KHR_DRACO_MESH_COMPRESSION: \"KHR_draco_mesh_compression\",\r\n  KHR_LIGHTS_PUNCTUAL: \"KHR_lights_punctual\",\r\n  KHR_MATERIALS_CLEARCOAT: \"KHR_materials_clearcoat\",\r\n  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: \"KHR_materials_pbrSpecularGlossiness\",\r\n  KHR_MATERIALS_TRANSMISSION: \"KHR_materials_transmission\",\r\n  KHR_MATERIALS_UNLIT: \"KHR_materials_unlit\",\r\n  KHR_TEXTURE_BASISU: \"KHR_texture_basisu\",\r\n  KHR_TEXTURE_TRANSFORM: \"KHR_texture_transform\",\r\n  KHR_MESH_QUANTIZATION: \"KHR_mesh_quantization\",\r\n  EXT_TEXTURE_WEBP: \"EXT_texture_webp\",\r\n  EXT_MESHOPT_COMPRESSION: \"EXT_meshopt_compression\",\r\n};\r\n\r\n/**\r\n * Punctual Lights Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\r\n */\r\nclass GLTFLightsExtension {\r\n  parser: any;\r\n  name: string;\r\n  cache: { refs: any; uses: any };\r\n  constructor(parser) {\r\n    this.parser = parser;\r\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\r\n\r\n    // Object3D instance caches\r\n    this.cache = { refs: {}, uses: {} };\r\n  }\r\n\r\n  _markDefs() {\r\n    const parser = this.parser;\r\n    const nodeDefs = this.parser.json.nodes || [];\r\n\r\n    for (\r\n      let nodeIndex = 0, nodeLength = nodeDefs.length;\r\n      nodeIndex < nodeLength;\r\n      nodeIndex++\r\n    ) {\r\n      const nodeDef = nodeDefs[nodeIndex];\r\n\r\n      if (\r\n        nodeDef.extensions &&\r\n        nodeDef.extensions[this.name] &&\r\n        nodeDef.extensions[this.name].light !== undefined\r\n      ) {\r\n        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\r\n      }\r\n    }\r\n  }\r\n\r\n  _loadLight(lightIndex) {\r\n    const parser = this.parser;\r\n    const cacheKey = \"light:\" + lightIndex;\r\n    let dependency = parser.cache.get(cacheKey);\r\n\r\n    if (dependency) return dependency;\r\n\r\n    const json = parser.json;\r\n    const extensions = (json.extensions && json.extensions[this.name]) || {};\r\n    const lightDefs = extensions.lights || [];\r\n    const lightDef = lightDefs[lightIndex];\r\n    let lightNode;\r\n\r\n    const color = new Color(0xffffff);\r\n\r\n    if (lightDef.color !== undefined) color.fromArray(lightDef.color);\r\n\r\n    const range = lightDef.range !== undefined ? lightDef.range : 0;\r\n\r\n    switch (lightDef.type) {\r\n      case \"directional\":\r\n        lightNode = new DirectionalLight(color);\r\n        lightNode.target.position.set(0, 0, -1);\r\n        lightNode.add(lightNode.target);\r\n        break;\r\n\r\n      case \"point\":\r\n        lightNode = new PointLight(color);\r\n        lightNode.distance = range;\r\n        break;\r\n\r\n      case \"spot\":\r\n        lightNode = new SpotLight(color);\r\n        lightNode.distance = range;\r\n        // Handle spotlight properties.\r\n        lightDef.spot = lightDef.spot || {};\r\n        lightDef.spot.innerConeAngle =\r\n          lightDef.spot.innerConeAngle !== undefined\r\n            ? lightDef.spot.innerConeAngle\r\n            : 0;\r\n        lightDef.spot.outerConeAngle =\r\n          lightDef.spot.outerConeAngle !== undefined\r\n            ? lightDef.spot.outerConeAngle\r\n            : Math.PI / 4.0;\r\n        lightNode.angle = lightDef.spot.outerConeAngle;\r\n        lightNode.penumbra =\r\n          1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\r\n        lightNode.target.position.set(0, 0, -1);\r\n        lightNode.add(lightNode.target);\r\n        break;\r\n\r\n      default:\r\n        throw new Error(\r\n          \"THREE.GLTFLoader: Unexpected light type: \" + lightDef.type\r\n        );\r\n    }\r\n\r\n    // Some lights (e.g. spot) default to a position other than the origin. Reset the position\r\n    // here, because node-level parsing will only override position if explicitly specified.\r\n    lightNode.position.set(0, 0, 0);\r\n\r\n    lightNode.decay = 2;\r\n\r\n    if (lightDef.intensity !== undefined)\r\n      lightNode.intensity = lightDef.intensity;\r\n\r\n    lightNode.name = parser.createUniqueName(\r\n      lightDef.name || \"light_\" + lightIndex\r\n    );\r\n\r\n    dependency = Promise.resolve(lightNode);\r\n\r\n    parser.cache.add(cacheKey, dependency);\r\n\r\n    return dependency;\r\n  }\r\n\r\n  createNodeAttachment(nodeIndex) {\r\n    const self = this;\r\n    const parser = this.parser;\r\n    const json = parser.json;\r\n    const nodeDef = json.nodes[nodeIndex];\r\n    const lightDef =\r\n      (nodeDef.extensions && nodeDef.extensions[this.name]) || {};\r\n    const lightIndex = lightDef.light;\r\n\r\n    if (lightIndex === undefined) return null;\r\n\r\n    return this._loadLight(lightIndex).then(function (light) {\r\n      return parser._getNodeRef(self.cache, lightIndex, light);\r\n    });\r\n  }\r\n}\r\n\r\n/**\r\n * Unlit Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\r\n */\r\nclass GLTFMaterialsUnlitExtension {\r\n  name: string;\r\n  constructor() {\r\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\r\n  }\r\n\r\n  getMaterialType() {\r\n    return MeshBasicMaterial;\r\n  }\r\n\r\n  extendParams(materialParams, materialDef, parser) {\r\n    const pending = [];\r\n\r\n    materialParams.color = new Color(1.0, 1.0, 1.0);\r\n    materialParams.opacity = 1.0;\r\n\r\n    const metallicRoughness = materialDef.pbrMetallicRoughness;\r\n\r\n    if (metallicRoughness) {\r\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\r\n        const array = metallicRoughness.baseColorFactor;\r\n\r\n        materialParams.color.fromArray(array);\r\n        materialParams.opacity = array[3];\r\n      }\r\n\r\n      if (metallicRoughness.baseColorTexture !== undefined) {\r\n        pending.push(\r\n          parser.assignTexture(\r\n            materialParams,\r\n            \"map\",\r\n            metallicRoughness.baseColorTexture\r\n          )\r\n        );\r\n      }\r\n    }\r\n\r\n    return Promise.all(pending);\r\n  }\r\n}\r\n\r\n/**\r\n * Clearcoat Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\r\n */\r\nclass GLTFMaterialsClearcoatExtension {\r\n  parser: any;\r\n  name: string;\r\n  constructor(parser) {\r\n    this.parser = parser;\r\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\r\n  }\r\n\r\n  getMaterialType(materialIndex) {\r\n    const parser = this.parser;\r\n    const materialDef = parser.json.materials[materialIndex];\r\n\r\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\r\n      return null;\r\n\r\n    return MeshPhysicalMaterial;\r\n  }\r\n\r\n  extendMaterialParams(materialIndex, materialParams) {\r\n    const parser = this.parser;\r\n    const materialDef = parser.json.materials[materialIndex];\r\n\r\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\r\n      return Promise.resolve();\r\n    }\r\n\r\n    const pending = [];\r\n\r\n    const extension = materialDef.extensions[this.name];\r\n\r\n    if (extension.clearcoatFactor !== undefined) {\r\n      materialParams.clearcoat = extension.clearcoatFactor;\r\n    }\r\n\r\n    if (extension.clearcoatTexture !== undefined) {\r\n      pending.push(\r\n        parser.assignTexture(\r\n          materialParams,\r\n          \"clearcoatMap\",\r\n          extension.clearcoatTexture\r\n        )\r\n      );\r\n    }\r\n\r\n    if (extension.clearcoatRoughnessFactor !== undefined) {\r\n      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\r\n    }\r\n\r\n    if (extension.clearcoatRoughnessTexture !== undefined) {\r\n      pending.push(\r\n        parser.assignTexture(\r\n          materialParams,\r\n          \"clearcoatRoughnessMap\",\r\n          extension.clearcoatRoughnessTexture\r\n        )\r\n      );\r\n    }\r\n\r\n    if (extension.clearcoatNormalTexture !== undefined) {\r\n      pending.push(\r\n        parser.assignTexture(\r\n          materialParams,\r\n          \"clearcoatNormalMap\",\r\n          extension.clearcoatNormalTexture\r\n        )\r\n      );\r\n\r\n      if (extension.clearcoatNormalTexture.scale !== undefined) {\r\n        const scale = extension.clearcoatNormalTexture.scale;\r\n\r\n        // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\r\n        materialParams.clearcoatNormalScale = new Vector2(scale, -scale);\r\n      }\r\n    }\r\n\r\n    return Promise.all(pending);\r\n  }\r\n}\r\n\r\n/**\r\n * Transmission Materials Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\r\n * Draft: https://github.com/KhronosGroup/glTF/pull/1698\r\n */\r\nclass GLTFMaterialsTransmissionExtension {\r\n  parser: any;\r\n  name: string;\r\n  constructor(parser) {\r\n    this.parser = parser;\r\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\r\n  }\r\n\r\n  getMaterialType(materialIndex) {\r\n    const parser = this.parser;\r\n    const materialDef = parser.json.materials[materialIndex];\r\n\r\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\r\n      return null;\r\n\r\n    return MeshPhysicalMaterial;\r\n  }\r\n\r\n  extendMaterialParams(materialIndex, materialParams) {\r\n    const parser = this.parser;\r\n    const materialDef = parser.json.materials[materialIndex];\r\n\r\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\r\n      return Promise.resolve();\r\n    }\r\n\r\n    const pending = [];\r\n\r\n    const extension = materialDef.extensions[this.name];\r\n\r\n    if (extension.transmissionFactor !== undefined) {\r\n      materialParams.transmission = extension.transmissionFactor;\r\n    }\r\n\r\n    if (extension.transmissionTexture !== undefined) {\r\n      pending.push(\r\n        parser.assignTexture(\r\n          materialParams,\r\n          \"transmissionMap\",\r\n          extension.transmissionTexture\r\n        )\r\n      );\r\n    }\r\n\r\n    return Promise.all(pending);\r\n  }\r\n}\r\n\r\n/**\r\n * BasisU Texture Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu\r\n */\r\nclass GLTFTextureBasisUExtension {\r\n  parser: any;\r\n  name: string;\r\n  constructor(parser) {\r\n    this.parser = parser;\r\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\r\n  }\r\n\r\n  loadTexture(textureIndex) {\r\n    const parser = this.parser;\r\n    const json = parser.json;\r\n\r\n    const textureDef = json.textures[textureIndex];\r\n\r\n    if (!textureDef.extensions || !textureDef.extensions[this.name]) {\r\n      return null;\r\n    }\r\n\r\n    const extension = textureDef.extensions[this.name];\r\n    const source = json.images[extension.source];\r\n    const loader = parser.options.ktx2Loader;\r\n\r\n    if (!loader) {\r\n      if (\r\n        json.extensionsRequired &&\r\n        json.extensionsRequired.indexOf(this.name) >= 0\r\n      ) {\r\n        throw new Error(\r\n          \"THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures\"\r\n        );\r\n      } else {\r\n        // Assumes that the extension is optional and that a fallback texture is present\r\n        return null;\r\n      }\r\n    }\r\n\r\n    return parser.loadTextureImage(textureIndex, source, loader);\r\n  }\r\n}\r\n\r\n/**\r\n * WebP Texture Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp\r\n */\r\nclass GLTFTextureWebPExtension {\r\n  parser: any;\r\n  name: string;\r\n  isSupported: any;\r\n  constructor(parser) {\r\n    this.parser = parser;\r\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\r\n    this.isSupported = null;\r\n  }\r\n\r\n  loadTexture(textureIndex) {\r\n    const name = this.name;\r\n    const parser = this.parser;\r\n    const json = parser.json;\r\n\r\n    const textureDef = json.textures[textureIndex];\r\n\r\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\r\n      return null;\r\n    }\r\n\r\n    const extension = textureDef.extensions[name];\r\n    const source = json.images[extension.source];\r\n\r\n    let loader = parser.textureLoader;\r\n    if (source.uri) {\r\n      const handler = parser.options.manager.getHandler(source.uri);\r\n      if (handler !== null) loader = handler;\r\n    }\r\n\r\n    return this.detectSupport().then(function (isSupported) {\r\n      if (isSupported)\r\n        return parser.loadTextureImage(textureIndex, source, loader);\r\n\r\n      if (\r\n        json.extensionsRequired &&\r\n        json.extensionsRequired.indexOf(name) >= 0\r\n      ) {\r\n        throw new Error(\r\n          \"THREE.GLTFLoader: WebP required by asset but unsupported.\"\r\n        );\r\n      }\r\n\r\n      // Fall back to PNG or JPEG.\r\n      return parser.loadTexture(textureIndex);\r\n    });\r\n  }\r\n\r\n  detectSupport() {\r\n    if (!this.isSupported) {\r\n      this.isSupported = new Promise(function (resolve) {\r\n        const image = new Image();\r\n\r\n        // Lossy test image. Support for lossy images doesn't guarantee support for all\r\n        // WebP images, unfortunately.\r\n        image.src =\r\n          \"data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\";\r\n\r\n        image.onload = image.onerror = function () {\r\n          resolve(image.height === 1);\r\n        };\r\n      });\r\n    }\r\n\r\n    return this.isSupported;\r\n  }\r\n}\r\n\r\n/**\r\n * meshopt BufferView Compression Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression\r\n */\r\nclass GLTFMeshoptCompression {\r\n  name: string;\r\n  parser: any;\r\n  constructor(parser) {\r\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\r\n    this.parser = parser;\r\n  }\r\n\r\n  loadBufferView(index) {\r\n    const json = this.parser.json;\r\n    const bufferView = json.bufferViews[index];\r\n\r\n    if (bufferView.extensions && bufferView.extensions[this.name]) {\r\n      const extensionDef = bufferView.extensions[this.name];\r\n\r\n      const buffer = this.parser.getDependency(\"buffer\", extensionDef.buffer);\r\n      const decoder = this.parser.options.meshoptDecoder;\r\n\r\n      if (!decoder || !decoder.supported) {\r\n        if (\r\n          json.extensionsRequired &&\r\n          json.extensionsRequired.indexOf(this.name) >= 0\r\n        ) {\r\n          throw new Error(\r\n            \"THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files\"\r\n          );\r\n        } else {\r\n          // Assumes that the extension is optional and that fallback buffer data is present\r\n          return null;\r\n        }\r\n      }\r\n\r\n      return Promise.all([buffer, decoder.ready]).then(function (res) {\r\n        const byteOffset = extensionDef.byteOffset || 0;\r\n        const byteLength = extensionDef.byteLength || 0;\r\n\r\n        const count = extensionDef.count;\r\n        const stride = extensionDef.byteStride;\r\n\r\n        const result = new ArrayBuffer(count * stride);\r\n        const source = new Uint8Array(res[0], byteOffset, byteLength);\r\n\r\n        decoder.decodeGltfBuffer(\r\n          new Uint8Array(result),\r\n          count,\r\n          stride,\r\n          source,\r\n          extensionDef.mode,\r\n          extensionDef.filter\r\n        );\r\n        return result;\r\n      });\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n}\r\n\r\n/* BINARY EXTENSION */\r\nconst BINARY_EXTENSION_HEADER_MAGIC = \"glTF\";\r\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\r\nconst BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4e4f534a, BIN: 0x004e4942 };\r\n\r\nclass GLTFBinaryExtension {\r\n  name: string;\r\n  content: any;\r\n  body: any;\r\n  header: { magic: string; version: number; length: number };\r\n  constructor(data) {\r\n    this.name = EXTENSIONS.KHR_BINARY_GLTF;\r\n    this.content = null;\r\n    this.body = null;\r\n\r\n    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\r\n\r\n    this.header = {\r\n      magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\r\n      version: headerView.getUint32(4, true),\r\n      length: headerView.getUint32(8, true),\r\n    };\r\n\r\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\r\n      throw new Error(\"THREE.GLTFLoader: Unsupported glTF-Binary header.\");\r\n    } else if (this.header.version < 2.0) {\r\n      throw new Error(\"THREE.GLTFLoader: Legacy binary file detected.\");\r\n    }\r\n\r\n    const chunkContentsLength =\r\n      this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\r\n    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\r\n    let chunkIndex = 0;\r\n\r\n    while (chunkIndex < chunkContentsLength) {\r\n      const chunkLength = chunkView.getUint32(chunkIndex, true);\r\n      chunkIndex += 4;\r\n\r\n      const chunkType = chunkView.getUint32(chunkIndex, true);\r\n      chunkIndex += 4;\r\n\r\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\r\n        const contentArray = new Uint8Array(\r\n          data,\r\n          BINARY_EXTENSION_HEADER_LENGTH + chunkIndex,\r\n          chunkLength\r\n        );\r\n        this.content = LoaderUtils.decodeText(contentArray);\r\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\r\n        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\r\n        this.body = data.slice(byteOffset, byteOffset + chunkLength);\r\n      }\r\n\r\n      // Clients must ignore chunks with unknown types.\r\n\r\n      chunkIndex += chunkLength;\r\n    }\r\n\r\n    if (this.content === null) {\r\n      throw new Error(\"THREE.GLTFLoader: JSON content not found.\");\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * DRACO Mesh Compression Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\r\n */\r\nclass GLTFDracoMeshCompressionExtension {\r\n  name: string;\r\n  json: any;\r\n  dracoLoader: any;\r\n  constructor(json, dracoLoader) {\r\n    if (!dracoLoader) {\r\n      throw new Error(\"THREE.GLTFLoader: No DRACOLoader instance provided.\");\r\n    }\r\n\r\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\r\n    this.json = json;\r\n    this.dracoLoader = dracoLoader;\r\n    this.dracoLoader.preload();\r\n  }\r\n\r\n  decodePrimitive(primitive, parser) {\r\n    const json = this.json;\r\n    const dracoLoader = this.dracoLoader;\r\n    const bufferViewIndex = primitive.extensions[this.name].bufferView;\r\n    const gltfAttributeMap = primitive.extensions[this.name].attributes;\r\n    const threeAttributeMap = {};\r\n    const attributeNormalizedMap = {};\r\n    const attributeTypeMap = {};\r\n\r\n    for (const attributeName in gltfAttributeMap) {\r\n      const threeAttributeName =\r\n        ATTRIBUTES[attributeName] || attributeName.toLowerCase();\r\n\r\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\r\n    }\r\n\r\n    for (const attributeName in primitive.attributes) {\r\n      const threeAttributeName =\r\n        ATTRIBUTES[attributeName] || attributeName.toLowerCase();\r\n\r\n      if (gltfAttributeMap[attributeName] !== undefined) {\r\n        const accessorDef = json.accessors[primitive.attributes[attributeName]];\r\n        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\r\n\r\n        attributeTypeMap[threeAttributeName] = componentType;\r\n        attributeNormalizedMap[threeAttributeName] =\r\n          accessorDef.normalized === true;\r\n      }\r\n    }\r\n\r\n    return parser\r\n      .getDependency(\"bufferView\", bufferViewIndex)\r\n      .then(function (bufferView) {\r\n        return new Promise(function (resolve) {\r\n          dracoLoader.decodeDracoFile(\r\n            bufferView,\r\n            function (geometry) {\r\n              for (const attributeName in geometry.attributes) {\r\n                const attribute = geometry.attributes[attributeName];\r\n                const normalized = attributeNormalizedMap[attributeName];\r\n\r\n                if (normalized !== undefined) attribute.normalized = normalized;\r\n              }\r\n\r\n              resolve(geometry);\r\n            },\r\n            threeAttributeMap,\r\n            attributeTypeMap\r\n          );\r\n        });\r\n      });\r\n  }\r\n}\r\n\r\n/**\r\n * Texture Transform Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform\r\n */\r\nclass GLTFTextureTransformExtension {\r\n  name: string;\r\n  constructor() {\r\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\r\n  }\r\n\r\n  extendTexture(texture, transform) {\r\n    if (transform.texCoord !== undefined) {\r\n      console.warn(\r\n        'THREE.GLTFLoader: Custom UV sets in \"' +\r\n          this.name +\r\n          '\" extension not yet supported.'\r\n      );\r\n    }\r\n\r\n    if (\r\n      transform.offset === undefined &&\r\n      transform.rotation === undefined &&\r\n      transform.scale === undefined\r\n    ) {\r\n      // See https://github.com/mrdoob/three.js/issues/21819.\r\n      return texture;\r\n    }\r\n\r\n    texture = texture.clone();\r\n\r\n    if (transform.offset !== undefined) {\r\n      texture.offset.fromArray(transform.offset);\r\n    }\r\n\r\n    if (transform.rotation !== undefined) {\r\n      texture.rotation = transform.rotation;\r\n    }\r\n\r\n    if (transform.scale !== undefined) {\r\n      texture.repeat.fromArray(transform.scale);\r\n    }\r\n\r\n    texture.needsUpdate = true;\r\n\r\n    return texture;\r\n  }\r\n}\r\n\r\n/**\r\n * Specular-Glossiness Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness\r\n */\r\n\r\n/**\r\n * A sub class of StandardMaterial with some of the functionality\r\n * changed via the `onBeforeCompile` callback\r\n * @pailhead\r\n */\r\nclass GLTFMeshStandardSGMaterial extends MeshStandardMaterial {\r\n  isGLTFSpecularGlossinessMaterial: boolean;\r\n  _extraUniforms: {\r\n    specular: { value: Color };\r\n    glossiness: { value: number };\r\n    specularMap: { value: any };\r\n    glossinessMap: { value: any };\r\n  };\r\n  specularMap: any;\r\n  specular: any;\r\n  glossinessMap: any;\r\n  glossiness: any;\r\n  constructor(params) {\r\n    super();\r\n\r\n    this.isGLTFSpecularGlossinessMaterial = true;\r\n\r\n    //various chunks that need replacing\r\n    const specularMapParsFragmentChunk = [\r\n      \"#ifdef USE_SPECULARMAP\",\r\n      \"\tuniform sampler2D specularMap;\",\r\n      \"#endif\",\r\n    ].join(\"\\n\");\r\n\r\n    const glossinessMapParsFragmentChunk = [\r\n      \"#ifdef USE_GLOSSINESSMAP\",\r\n      \"\tuniform sampler2D glossinessMap;\",\r\n      \"#endif\",\r\n    ].join(\"\\n\");\r\n\r\n    const specularMapFragmentChunk = [\r\n      \"vec3 specularFactor = specular;\",\r\n      \"#ifdef USE_SPECULARMAP\",\r\n      \"\tvec4 texelSpecular = texture2D( specularMap, vUv );\",\r\n      \"\ttexelSpecular = sRGBToLinear( texelSpecular );\",\r\n      \"\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture\",\r\n      \"\tspecularFactor *= texelSpecular.rgb;\",\r\n      \"#endif\",\r\n    ].join(\"\\n\");\r\n\r\n    const glossinessMapFragmentChunk = [\r\n      \"float glossinessFactor = glossiness;\",\r\n      \"#ifdef USE_GLOSSINESSMAP\",\r\n      \"\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );\",\r\n      \"\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture\",\r\n      \"\tglossinessFactor *= texelGlossiness.a;\",\r\n      \"#endif\",\r\n    ].join(\"\\n\");\r\n\r\n    const lightPhysicalFragmentChunk = [\r\n      \"PhysicalMaterial material;\",\r\n      \"material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );\",\r\n      \"vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\",\r\n      \"float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\",\r\n      \"material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.\",\r\n      \"material.specularRoughness += geometryRoughness;\",\r\n      \"material.specularRoughness = min( material.specularRoughness, 1.0 );\",\r\n      \"material.specularColor = specularFactor;\",\r\n    ].join(\"\\n\");\r\n\r\n    const uniforms = {\r\n      specular: { value: new Color().setHex(0xffffff) },\r\n      glossiness: { value: 1 },\r\n      specularMap: { value: null },\r\n      glossinessMap: { value: null },\r\n    };\r\n\r\n    this._extraUniforms = uniforms;\r\n\r\n    this.onBeforeCompile = function (shader) {\r\n      for (const uniformName in uniforms) {\r\n        shader.uniforms[uniformName] = uniforms[uniformName];\r\n      }\r\n\r\n      shader.fragmentShader = shader.fragmentShader\r\n        .replace(\"uniform float roughness;\", \"uniform vec3 specular;\")\r\n        .replace(\"uniform float metalness;\", \"uniform float glossiness;\")\r\n        .replace(\r\n          \"#include <roughnessmap_pars_fragment>\",\r\n          specularMapParsFragmentChunk\r\n        )\r\n        .replace(\r\n          \"#include <metalnessmap_pars_fragment>\",\r\n          glossinessMapParsFragmentChunk\r\n        )\r\n        .replace(\"#include <roughnessmap_fragment>\", specularMapFragmentChunk)\r\n        .replace(\"#include <metalnessmap_fragment>\", glossinessMapFragmentChunk)\r\n        .replace(\r\n          \"#include <lights_physical_fragment>\",\r\n          lightPhysicalFragmentChunk\r\n        );\r\n    };\r\n\r\n    Object.defineProperties(this, {\r\n      specular: {\r\n        get: function () {\r\n          return uniforms.specular.value;\r\n        },\r\n        set: function (v) {\r\n          uniforms.specular.value = v;\r\n        },\r\n      },\r\n\r\n      specularMap: {\r\n        get: function () {\r\n          return uniforms.specularMap.value;\r\n        },\r\n        set: function (v) {\r\n          uniforms.specularMap.value = v;\r\n\r\n          if (v) {\r\n            this.defines.USE_SPECULARMAP = \"\"; // USE_UV is set by the renderer for specular maps\r\n          } else {\r\n            delete this.defines.USE_SPECULARMAP;\r\n          }\r\n        },\r\n      },\r\n\r\n      glossiness: {\r\n        get: function () {\r\n          return uniforms.glossiness.value;\r\n        },\r\n        set: function (v) {\r\n          uniforms.glossiness.value = v;\r\n        },\r\n      },\r\n\r\n      glossinessMap: {\r\n        get: function () {\r\n          return uniforms.glossinessMap.value;\r\n        },\r\n        set: function (v) {\r\n          uniforms.glossinessMap.value = v;\r\n\r\n          if (v) {\r\n            this.defines.USE_GLOSSINESSMAP = \"\";\r\n            this.defines.USE_UV = \"\";\r\n          } else {\r\n            delete this.defines.USE_GLOSSINESSMAP;\r\n            delete this.defines.USE_UV;\r\n          }\r\n        },\r\n      },\r\n    });\r\n\r\n    delete this.metalness;\r\n    delete this.roughness;\r\n    delete this.metalnessMap;\r\n    delete this.roughnessMap;\r\n\r\n    this.setValues(params);\r\n  }\r\n\r\n  copy(source) {\r\n    super.copy(source);\r\n\r\n    this.specularMap = source.specularMap;\r\n    this.specular.copy(source.specular);\r\n    this.glossinessMap = source.glossinessMap;\r\n    this.glossiness = source.glossiness;\r\n    delete this.metalness;\r\n    delete this.roughness;\r\n    delete this.metalnessMap;\r\n    delete this.roughnessMap;\r\n    return this;\r\n  }\r\n}\r\n\r\nclass GLTFMaterialsPbrSpecularGlossinessExtension {\r\n  name: string;\r\n  specularGlossinessParams: string[];\r\n  constructor() {\r\n    this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\r\n\r\n    this.specularGlossinessParams = [\r\n      \"color\",\r\n      \"map\",\r\n      \"lightMap\",\r\n      \"lightMapIntensity\",\r\n      \"aoMap\",\r\n      \"aoMapIntensity\",\r\n      \"emissive\",\r\n      \"emissiveIntensity\",\r\n      \"emissiveMap\",\r\n      \"bumpMap\",\r\n      \"bumpScale\",\r\n      \"normalMap\",\r\n      \"normalMapType\",\r\n      \"displacementMap\",\r\n      \"displacementScale\",\r\n      \"displacementBias\",\r\n      \"specularMap\",\r\n      \"specular\",\r\n      \"glossinessMap\",\r\n      \"glossiness\",\r\n      \"alphaMap\",\r\n      \"envMap\",\r\n      \"envMapIntensity\",\r\n      \"refractionRatio\",\r\n    ];\r\n  }\r\n\r\n  getMaterialType() {\r\n    return GLTFMeshStandardSGMaterial;\r\n  }\r\n\r\n  extendParams(materialParams, materialDef, parser) {\r\n    const pbrSpecularGlossiness = materialDef.extensions[this.name];\r\n\r\n    materialParams.color = new Color(1.0, 1.0, 1.0);\r\n    materialParams.opacity = 1.0;\r\n\r\n    const pending = [];\r\n\r\n    if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {\r\n      const array = pbrSpecularGlossiness.diffuseFactor;\r\n\r\n      materialParams.color.fromArray(array);\r\n      materialParams.opacity = array[3];\r\n    }\r\n\r\n    if (pbrSpecularGlossiness.diffuseTexture !== undefined) {\r\n      pending.push(\r\n        parser.assignTexture(\r\n          materialParams,\r\n          \"map\",\r\n          pbrSpecularGlossiness.diffuseTexture\r\n        )\r\n      );\r\n    }\r\n\r\n    materialParams.emissive = new Color(0.0, 0.0, 0.0);\r\n    materialParams.glossiness =\r\n      pbrSpecularGlossiness.glossinessFactor !== undefined\r\n        ? pbrSpecularGlossiness.glossinessFactor\r\n        : 1.0;\r\n    materialParams.specular = new Color(1.0, 1.0, 1.0);\r\n\r\n    if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {\r\n      materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);\r\n    }\r\n\r\n    if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {\r\n      const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\r\n      pending.push(\r\n        parser.assignTexture(materialParams, \"glossinessMap\", specGlossMapDef)\r\n      );\r\n      pending.push(\r\n        parser.assignTexture(materialParams, \"specularMap\", specGlossMapDef)\r\n      );\r\n    }\r\n\r\n    return Promise.all(pending);\r\n  }\r\n\r\n  createMaterial(materialParams) {\r\n    const material = new GLTFMeshStandardSGMaterial(materialParams);\r\n    material.fog = true;\r\n\r\n    material.color = materialParams.color;\r\n\r\n    material.map = materialParams.map === undefined ? null : materialParams.map;\r\n\r\n    material.lightMap = null;\r\n    material.lightMapIntensity = 1.0;\r\n\r\n    material.aoMap =\r\n      materialParams.aoMap === undefined ? null : materialParams.aoMap;\r\n    material.aoMapIntensity = 1.0;\r\n\r\n    material.emissive = materialParams.emissive;\r\n    material.emissiveIntensity = 1.0;\r\n    material.emissiveMap =\r\n      materialParams.emissiveMap === undefined\r\n        ? null\r\n        : materialParams.emissiveMap;\r\n\r\n    material.bumpMap =\r\n      materialParams.bumpMap === undefined ? null : materialParams.bumpMap;\r\n    material.bumpScale = 1;\r\n\r\n    material.normalMap =\r\n      materialParams.normalMap === undefined ? null : materialParams.normalMap;\r\n    material.normalMapType = TangentSpaceNormalMap;\r\n\r\n    if (materialParams.normalScale)\r\n      material.normalScale = materialParams.normalScale;\r\n\r\n    material.displacementMap = null;\r\n    material.displacementScale = 1;\r\n    material.displacementBias = 0;\r\n\r\n    material.specularMap =\r\n      materialParams.specularMap === undefined\r\n        ? null\r\n        : materialParams.specularMap;\r\n    material.specular = materialParams.specular;\r\n\r\n    material.glossinessMap =\r\n      materialParams.glossinessMap === undefined\r\n        ? null\r\n        : materialParams.glossinessMap;\r\n    material.glossiness = materialParams.glossiness;\r\n\r\n    material.alphaMap = null;\r\n\r\n    material.envMap =\r\n      materialParams.envMap === undefined ? null : materialParams.envMap;\r\n    material.envMapIntensity = 1.0;\r\n\r\n    material.refractionRatio = 0.98;\r\n\r\n    return material;\r\n  }\r\n}\r\n\r\n/**\r\n * Mesh Quantization Extension\r\n *\r\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization\r\n */\r\nclass GLTFMeshQuantizationExtension {\r\n  name: string;\r\n  constructor() {\r\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\r\n  }\r\n}\r\n\r\n/*********************************/\r\n/********** INTERPOLATION ********/\r\n/*********************************/\r\n\r\n// Spline Interpolation\r\n// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation\r\nclass GLTFCubicSplineInterpolant extends Interpolant {\r\n  beforeStart_: (index: any) => any;\r\n  afterEnd_: (index: any) => any;\r\n  interpolate_: (i1: any, t0: any, t: any, t1: any) => any;\r\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\r\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\r\n  }\r\n\r\n  copySampleValue_(index) {\r\n    // Copies a sample value to the result buffer. See description of glTF\r\n    // CUBICSPLINE values layout in interpolate_() function below.\r\n\r\n    const result = this.resultBuffer,\r\n      values = this.sampleValues,\r\n      valueSize = this.valueSize,\r\n      offset = index * valueSize * 3 + valueSize;\r\n\r\n    for (let i = 0; i !== valueSize; i++) {\r\n      result[i] = values[offset + i];\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n\r\nGLTFCubicSplineInterpolant.prototype.beforeStart_ =\r\n  GLTFCubicSplineInterpolant.prototype.copySampleValue_;\r\n\r\nGLTFCubicSplineInterpolant.prototype.afterEnd_ =\r\n  GLTFCubicSplineInterpolant.prototype.copySampleValue_;\r\n\r\nGLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {\r\n  const result = this.resultBuffer;\r\n  const values = this.sampleValues;\r\n  const stride = this.valueSize;\r\n\r\n  const stride2 = stride * 2;\r\n  const stride3 = stride * 3;\r\n\r\n  const td = t1 - t0;\r\n\r\n  const p = (t - t0) / td;\r\n  const pp = p * p;\r\n  const ppp = pp * p;\r\n\r\n  const offset1 = i1 * stride3;\r\n  const offset0 = offset1 - stride3;\r\n\r\n  const s2 = -2 * ppp + 3 * pp;\r\n  const s3 = ppp - pp;\r\n  const s0 = 1 - s2;\r\n  const s1 = s3 - pp + p;\r\n\r\n  // Layout of keyframe output values for CUBICSPLINE animations:\r\n  //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]\r\n  for (let i = 0; i !== stride; i++) {\r\n    const p0 = values[offset0 + i + stride]; // splineVertex_k\r\n    const m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)\r\n    const p1 = values[offset1 + i + stride]; // splineVertex_k+1\r\n    const m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)\r\n\r\n    result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n/*********************************/\r\n/********** INTERNALS ************/\r\n/*********************************/\r\n\r\n/* CONSTANTS */\r\n\r\nconst WEBGL_CONSTANTS = {\r\n  FLOAT: 5126,\r\n  //FLOAT_MAT2: 35674,\r\n  FLOAT_MAT3: 35675,\r\n  FLOAT_MAT4: 35676,\r\n  FLOAT_VEC2: 35664,\r\n  FLOAT_VEC3: 35665,\r\n  FLOAT_VEC4: 35666,\r\n  LINEAR: 9729,\r\n  REPEAT: 10497,\r\n  SAMPLER_2D: 35678,\r\n  POINTS: 0,\r\n  LINES: 1,\r\n  LINE_LOOP: 2,\r\n  LINE_STRIP: 3,\r\n  TRIANGLES: 4,\r\n  TRIANGLE_STRIP: 5,\r\n  TRIANGLE_FAN: 6,\r\n  UNSIGNED_BYTE: 5121,\r\n  UNSIGNED_SHORT: 5123,\r\n};\r\n\r\nconst WEBGL_COMPONENT_TYPES = {\r\n  5120: Int8Array,\r\n  5121: Uint8Array,\r\n  5122: Int16Array,\r\n  5123: Uint16Array,\r\n  5125: Uint32Array,\r\n  5126: Float32Array,\r\n};\r\n\r\nconst WEBGL_FILTERS = {\r\n  9728: NearestFilter,\r\n  9729: LinearFilter,\r\n  9984: NearestMipmapNearestFilter,\r\n  9985: LinearMipmapNearestFilter,\r\n  9986: NearestMipmapLinearFilter,\r\n  9987: LinearMipmapLinearFilter,\r\n};\r\n\r\nconst WEBGL_WRAPPINGS = {\r\n  33071: ClampToEdgeWrapping,\r\n  33648: MirroredRepeatWrapping,\r\n  10497: RepeatWrapping,\r\n};\r\n\r\nconst WEBGL_TYPE_SIZES = {\r\n  SCALAR: 1,\r\n  VEC2: 2,\r\n  VEC3: 3,\r\n  VEC4: 4,\r\n  MAT2: 4,\r\n  MAT3: 9,\r\n  MAT4: 16,\r\n};\r\n\r\nconst ATTRIBUTES = {\r\n  POSITION: \"position\",\r\n  NORMAL: \"normal\",\r\n  TANGENT: \"tangent\",\r\n  TEXCOORD_0: \"uv\",\r\n  TEXCOORD_1: \"uv2\",\r\n  COLOR_0: \"color\",\r\n  WEIGHTS_0: \"skinWeight\",\r\n  JOINTS_0: \"skinIndex\",\r\n};\r\n\r\nconst PATH_PROPERTIES = {\r\n  scale: \"scale\",\r\n  translation: \"position\",\r\n  rotation: \"quaternion\",\r\n  weights: \"morphTargetInfluences\",\r\n} as any;\r\n\r\nconst INTERPOLATION = {\r\n  CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each\r\n  // keyframe track will be initialized with a default interpolation type, then modified.\r\n  LINEAR: InterpolateLinear,\r\n  STEP: InterpolateDiscrete,\r\n};\r\n\r\nconst ALPHA_MODES = {\r\n  OPAQUE: \"OPAQUE\",\r\n  MASK: \"MASK\",\r\n  BLEND: \"BLEND\",\r\n};\r\n\r\n/* UTILITY FUNCTIONS */\r\n\r\nfunction resolveURL(url, path) {\r\n  // Invalid URL\r\n  if (typeof url !== \"string\" || url === \"\") return \"\";\r\n\r\n  // Host Relative URL\r\n  if (/^https?:\\/\\//i.test(path) && /^\\//.test(url)) {\r\n    path = path.replace(/(^https?:\\/\\/[^\\/]+).*/i, \"$1\");\r\n  }\r\n\r\n  // Absolute URL http://,https://,//\r\n  if (/^(https?:)?\\/\\//i.test(url)) return url;\r\n\r\n  // Data URI\r\n  if (/^data:.*,.*$/i.test(url)) return url;\r\n\r\n  // Blob URL\r\n  if (/^blob:.*$/i.test(url)) return url;\r\n\r\n  // Relative URL\r\n  return path + url;\r\n}\r\n\r\n/**\r\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material\r\n */\r\nfunction createDefaultMaterial(cache) {\r\n  if (cache[\"DefaultMaterial\"] === undefined) {\r\n    cache[\"DefaultMaterial\"] = new MeshStandardMaterial({\r\n      color: 0xffffff,\r\n      emissive: 0x000000,\r\n      metalness: 1,\r\n      roughness: 1,\r\n      transparent: false,\r\n      depthTest: true,\r\n      side: FrontSide,\r\n    });\r\n  }\r\n\r\n  return cache[\"DefaultMaterial\"];\r\n}\r\n\r\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\r\n  // Add unknown glTF extensions to an object's userData.\r\n\r\n  for (const name in objectDef.extensions) {\r\n    if (knownExtensions[name] === undefined) {\r\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {};\r\n      object.userData.gltfExtensions[name] = objectDef.extensions[name];\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Object3D|Material|BufferGeometry} object\r\n * @param {GLTF.definition} gltfDef\r\n */\r\nfunction assignExtrasToUserData(object, gltfDef) {\r\n  if (gltfDef.extras !== undefined) {\r\n    if (typeof gltfDef.extras === \"object\") {\r\n      Object.assign(object.userData, gltfDef.extras);\r\n    } else {\r\n      console.warn(\r\n        \"THREE.GLTFLoader: Ignoring primitive type .extras, \" + gltfDef.extras\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets\r\n *\r\n * @param {BufferGeometry} geometry\r\n * @param {Array<GLTF.Target>} targets\r\n * @param {GLTFParser} parser\r\n * @return {Promise<BufferGeometry>}\r\n */\r\nfunction addMorphTargets(geometry, targets, parser) {\r\n  let hasMorphPosition = false;\r\n  let hasMorphNormal = false;\r\n\r\n  for (let i = 0, il = targets.length; i < il; i++) {\r\n    const target = targets[i];\r\n\r\n    if (target.POSITION !== undefined) hasMorphPosition = true;\r\n    if (target.NORMAL !== undefined) hasMorphNormal = true;\r\n\r\n    if (hasMorphPosition && hasMorphNormal) break;\r\n  }\r\n\r\n  if (!hasMorphPosition && !hasMorphNormal) return Promise.resolve(geometry);\r\n\r\n  const pendingPositionAccessors = [];\r\n  const pendingNormalAccessors = [];\r\n\r\n  for (let i = 0, il = targets.length; i < il; i++) {\r\n    const target = targets[i];\r\n\r\n    if (hasMorphPosition) {\r\n      const pendingAccessor =\r\n        target.POSITION !== undefined\r\n          ? parser.getDependency(\"accessor\", target.POSITION)\r\n          : geometry.attributes.position;\r\n\r\n      pendingPositionAccessors.push(pendingAccessor);\r\n    }\r\n\r\n    if (hasMorphNormal) {\r\n      const pendingAccessor =\r\n        target.NORMAL !== undefined\r\n          ? parser.getDependency(\"accessor\", target.NORMAL)\r\n          : geometry.attributes.normal;\r\n\r\n      pendingNormalAccessors.push(pendingAccessor);\r\n    }\r\n  }\r\n\r\n  return Promise.all([\r\n    Promise.all(pendingPositionAccessors),\r\n    Promise.all(pendingNormalAccessors),\r\n  ]).then(function (accessors) {\r\n    const morphPositions = accessors[0];\r\n    const morphNormals = accessors[1];\r\n\r\n    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;\r\n    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;\r\n    geometry.morphTargetsRelative = true;\r\n\r\n    return geometry;\r\n  });\r\n}\r\n\r\n/**\r\n * @param {Mesh} mesh\r\n * @param {GLTF.Mesh} meshDef\r\n */\r\nfunction updateMorphTargets(mesh, meshDef) {\r\n  mesh.updateMorphTargets();\r\n\r\n  if (meshDef.weights !== undefined) {\r\n    for (let i = 0, il = meshDef.weights.length; i < il; i++) {\r\n      mesh.morphTargetInfluences[i] = meshDef.weights[i];\r\n    }\r\n  }\r\n\r\n  // .extras has user-defined data, so check that .extras.targetNames is an array.\r\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\r\n    const targetNames = meshDef.extras.targetNames;\r\n\r\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\r\n      mesh.morphTargetDictionary = {};\r\n\r\n      for (let i = 0, il = targetNames.length; i < il; i++) {\r\n        mesh.morphTargetDictionary[targetNames[i]] = i;\r\n      }\r\n    } else {\r\n      console.warn(\r\n        \"THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.\"\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\nfunction createPrimitiveKey(primitiveDef) {\r\n  const dracoExtension =\r\n    primitiveDef.extensions &&\r\n    primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\r\n  let geometryKey;\r\n\r\n  if (dracoExtension) {\r\n    geometryKey =\r\n      \"draco:\" +\r\n      dracoExtension.bufferView +\r\n      \":\" +\r\n      dracoExtension.indices +\r\n      \":\" +\r\n      createAttributesKey(dracoExtension.attributes);\r\n  } else {\r\n    geometryKey =\r\n      primitiveDef.indices +\r\n      \":\" +\r\n      createAttributesKey(primitiveDef.attributes) +\r\n      \":\" +\r\n      primitiveDef.mode;\r\n  }\r\n\r\n  return geometryKey;\r\n}\r\n\r\nfunction createAttributesKey(attributes) {\r\n  let attributesKey = \"\";\r\n\r\n  const keys = Object.keys(attributes).sort();\r\n\r\n  for (let i = 0, il = keys.length; i < il; i++) {\r\n    attributesKey += keys[i] + \":\" + attributes[keys[i]] + \";\";\r\n  }\r\n\r\n  return attributesKey;\r\n}\r\n\r\nfunction getNormalizedComponentScale(constructor) {\r\n  // Reference:\r\n  // https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data\r\n\r\n  switch (constructor) {\r\n    case Int8Array:\r\n      return 1 / 127;\r\n\r\n    case Uint8Array:\r\n      return 1 / 255;\r\n\r\n    case Int16Array:\r\n      return 1 / 32767;\r\n\r\n    case Uint16Array:\r\n      return 1 / 65535;\r\n\r\n    default:\r\n      throw new Error(\r\n        \"THREE.GLTFLoader: Unsupported normalized accessor component type.\"\r\n      );\r\n  }\r\n}\r\n\r\n/* GLTF PARSER */\r\n\r\nclass GLTFParser {\r\n  fileLoader: any;\r\n  json: any;\r\n  extensions: any;\r\n  plugins: any;\r\n  options: any;\r\n  cache: any;\r\n  associations: Map<any, any>;\r\n  primitiveCache: any;\r\n  meshCache: { refs: any; uses: any };\r\n  cameraCache: { refs: any; uses: any };\r\n  lightCache: { refs: any; uses: any };\r\n  textureCache: any;\r\n  nodeNamesUsed: any;\r\n  textureLoader: any;\r\n  URL: any;\r\n  webkitURL: any;\r\n  constructor(json = {}, options = {}) {\r\n    this.json = json;\r\n    this.extensions = {};\r\n    this.plugins = {};\r\n    this.options = options;\r\n\r\n    // loader object cache\r\n    this.cache = GLTFRegistry();\r\n\r\n    // associations between Three.js objects and glTF elements\r\n    this.associations = new Map();\r\n\r\n    // BufferGeometry caching\r\n    this.primitiveCache = {};\r\n\r\n    // Object3D instance caches\r\n    this.meshCache = { refs: {}, uses: {} };\r\n    this.cameraCache = { refs: {}, uses: {} };\r\n    this.lightCache = { refs: {}, uses: {} };\r\n\r\n    this.textureCache = {};\r\n\r\n    // Track node names, to ensure no duplicates\r\n    this.nodeNamesUsed = {};\r\n\r\n    // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the\r\n    // expensive work of uploading a texture to the GPU off the main thread.\r\n    if (\r\n      typeof createImageBitmap !== \"undefined\" &&\r\n      /Firefox/.test(navigator.userAgent) === false\r\n    ) {\r\n      this.textureLoader = new ImageBitmapLoader(this.options.manager);\r\n    } else {\r\n      this.textureLoader = new TextureLoader(this.options.manager);\r\n    }\r\n\r\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin);\r\n    this.textureLoader.setRequestHeader(this.options.requestHeader);\r\n\r\n    this.fileLoader = new FileLoader(this.options.manager);\r\n    this.fileLoader.setResponseType(\"arraybuffer\");\r\n\r\n    if (this.options.crossOrigin === \"use-credentials\") {\r\n      this.fileLoader.setWithCredentials(true);\r\n    }\r\n  }\r\n\r\n  setExtensions(extensions) {\r\n    this.extensions = extensions;\r\n  }\r\n\r\n  setPlugins(plugins) {\r\n    this.plugins = plugins;\r\n  }\r\n\r\n  parse(onLoad, onError) {\r\n    const parser = this;\r\n    const json = this.json;\r\n    const extensions = this.extensions;\r\n\r\n    // Clear the loader cache\r\n    this.cache.removeAll();\r\n\r\n    // Mark the special nodes/meshes in json for efficient parse\r\n    this._invokeAll(function (ext) {\r\n      return ext._markDefs && ext._markDefs();\r\n    });\r\n\r\n    Promise.all(\r\n      this._invokeAll(function (ext) {\r\n        return ext.beforeRoot && ext.beforeRoot();\r\n      })\r\n    )\r\n      .then(function () {\r\n        return Promise.all([\r\n          parser.getDependencies(\"scene\"),\r\n          parser.getDependencies(\"animation\"),\r\n          parser.getDependencies(\"camera\"),\r\n        ]);\r\n      })\r\n      .then(function (dependencies) {\r\n        const result = {\r\n          scene: dependencies[0][json.scene || 0],\r\n          scenes: dependencies[0],\r\n          animations: dependencies[1],\r\n          cameras: dependencies[2],\r\n          asset: json.asset,\r\n          parser: parser,\r\n          userData: {},\r\n        };\r\n\r\n        addUnknownExtensionsToUserData(extensions, result, json);\r\n\r\n        assignExtrasToUserData(result, json);\r\n\r\n        Promise.all(\r\n          parser._invokeAll(function (ext) {\r\n            return ext.afterRoot && ext.afterRoot(result);\r\n          })\r\n        ).then(function () {\r\n          onLoad(result);\r\n        });\r\n      })\r\n      .catch(onError);\r\n  }\r\n\r\n  /**\r\n   * Marks the special nodes/meshes in json for efficient parse.\r\n   */\r\n  _markDefs() {\r\n    const nodeDefs = this.json.nodes || [];\r\n    const skinDefs = this.json.skins || [];\r\n    const meshDefs = this.json.meshes || [];\r\n\r\n    // Nothing in the node definition indicates whether it is a Bone or an\r\n    // Object3D. Use the skins' joint references to mark bones.\r\n    for (\r\n      let skinIndex = 0, skinLength = skinDefs.length;\r\n      skinIndex < skinLength;\r\n      skinIndex++\r\n    ) {\r\n      const joints = skinDefs[skinIndex].joints;\r\n\r\n      for (let i = 0, il = joints.length; i < il; i++) {\r\n        nodeDefs[joints[i]].isBone = true;\r\n      }\r\n    }\r\n\r\n    // Iterate over all nodes, marking references to shared resources,\r\n    // as well as skeleton joints.\r\n    for (\r\n      let nodeIndex = 0, nodeLength = nodeDefs.length;\r\n      nodeIndex < nodeLength;\r\n      nodeIndex++\r\n    ) {\r\n      const nodeDef = nodeDefs[nodeIndex];\r\n\r\n      if (nodeDef.mesh !== undefined) {\r\n        this._addNodeRef(this.meshCache, nodeDef.mesh);\r\n\r\n        // Nothing in the mesh definition indicates whether it is\r\n        // a SkinnedMesh or Mesh. Use the node's mesh reference\r\n        // to mark SkinnedMesh if node has skin.\r\n        if (nodeDef.skin !== undefined) {\r\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true;\r\n        }\r\n      }\r\n\r\n      if (nodeDef.camera !== undefined) {\r\n        this._addNodeRef(this.cameraCache, nodeDef.camera);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Counts references to shared node / Object3D resources. These resources\r\n   * can be reused, or \"instantiated\", at multiple nodes in the scene\r\n   * hierarchy. Mesh, Camera, and Light instances are instantiated and must\r\n   * be marked. Non-scenegraph resources (like Materials, Geometries, and\r\n   * Textures) can be reused directly and are not marked here.\r\n   *\r\n   * Example: CesiumMilkTruck sample model reuses \"Wheel\" meshes.\r\n   */\r\n  _addNodeRef(cache, index) {\r\n    if (index === undefined) return;\r\n\r\n    if (cache.refs[index] === undefined) {\r\n      cache.refs[index] = cache.uses[index] = 0;\r\n    }\r\n\r\n    cache.refs[index]++;\r\n  }\r\n\r\n  /** Returns a reference to a shared resource, cloning it if necessary. */\r\n  _getNodeRef(cache, index, object) {\r\n    if (cache.refs[index] <= 1) return object;\r\n\r\n    const ref = object.clone();\r\n\r\n    ref.name += \"_instance_\" + cache.uses[index]++;\r\n\r\n    return ref;\r\n  }\r\n\r\n  _invokeOne(func) {\r\n    const extensions = Object.values(this.plugins);\r\n    extensions.push(this);\r\n\r\n    for (let i = 0; i < extensions.length; i++) {\r\n      const result = func(extensions[i]);\r\n\r\n      if (result) return result;\r\n    }\r\n\r\n    return null;\r\n  }\r\n\r\n  _invokeAll(func) {\r\n    const extensions = Object.values(this.plugins);\r\n    extensions.unshift(this);\r\n\r\n    const pending = [];\r\n\r\n    for (let i = 0; i < extensions.length; i++) {\r\n      const result = func(extensions[i]);\r\n\r\n      if (result) pending.push(result);\r\n    }\r\n\r\n    return pending;\r\n  }\r\n\r\n  /**\r\n   * Requests the specified dependency asynchronously, with caching.\r\n   * @param {string} type\r\n   * @param {number} index\r\n   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}\r\n   */\r\n  getDependency(type, index) {\r\n    const cacheKey = type + \":\" + index;\r\n    let dependency = this.cache.get(cacheKey);\r\n\r\n    if (!dependency) {\r\n      switch (type) {\r\n        case \"scene\":\r\n          dependency = this.loadScene(index);\r\n          break;\r\n\r\n        case \"node\":\r\n          dependency = this.loadNode(index);\r\n          break;\r\n\r\n        case \"mesh\":\r\n          dependency = this._invokeOne(function (ext) {\r\n            return ext.loadMesh && ext.loadMesh(index);\r\n          });\r\n          break;\r\n\r\n        case \"accessor\":\r\n          dependency = this.loadAccessor(index);\r\n          break;\r\n\r\n        case \"bufferView\":\r\n          dependency = this._invokeOne(function (ext) {\r\n            return ext.loadBufferView && ext.loadBufferView(index);\r\n          });\r\n          break;\r\n\r\n        case \"buffer\":\r\n          dependency = this.loadBuffer(index);\r\n          break;\r\n\r\n        case \"material\":\r\n          dependency = this._invokeOne(function (ext) {\r\n            return ext.loadMaterial && ext.loadMaterial(index);\r\n          });\r\n          break;\r\n\r\n        case \"texture\":\r\n          dependency = this._invokeOne(function (ext) {\r\n            return ext.loadTexture && ext.loadTexture(index);\r\n          });\r\n          break;\r\n\r\n        case \"skin\":\r\n          dependency = this.loadSkin(index);\r\n          break;\r\n\r\n        case \"animation\":\r\n          dependency = this.loadAnimation(index);\r\n          break;\r\n\r\n        case \"camera\":\r\n          dependency = this.loadCamera(index);\r\n          break;\r\n\r\n        default:\r\n          throw new Error(\"Unknown type: \" + type);\r\n      }\r\n\r\n      this.cache.add(cacheKey, dependency);\r\n    }\r\n\r\n    return dependency;\r\n  }\r\n\r\n  /**\r\n   * Requests all dependencies of the specified type asynchronously, with caching.\r\n   * @param {string} type\r\n   * @return {Promise<Array<Object>>}\r\n   */\r\n  getDependencies(type) {\r\n    let dependencies = this.cache.get(type);\r\n\r\n    if (!dependencies) {\r\n      const parser = this;\r\n      const defs = this.json[type + (type === \"mesh\" ? \"es\" : \"s\")] || [];\r\n\r\n      dependencies = Promise.all(\r\n        defs.map(function (def, index) {\r\n          return parser.getDependency(type, index);\r\n        })\r\n      );\r\n\r\n      this.cache.add(type, dependencies);\r\n    }\r\n\r\n    return dependencies;\r\n  }\r\n\r\n  /**\r\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\r\n   * @param {number} bufferIndex\r\n   * @return {Promise<ArrayBuffer>}\r\n   */\r\n  loadBuffer(bufferIndex) {\r\n    const bufferDef = this.json.buffers[bufferIndex];\r\n    const loader = this.fileLoader;\r\n\r\n    if (bufferDef.type && bufferDef.type !== \"arraybuffer\") {\r\n      throw new Error(\r\n        \"THREE.GLTFLoader: \" + bufferDef.type + \" buffer type is not supported.\"\r\n      );\r\n    }\r\n\r\n    // If present, GLB container is required to be the first buffer.\r\n    if (bufferDef.uri === undefined && bufferIndex === 0) {\r\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\r\n    }\r\n\r\n    const options = this.options;\r\n\r\n    return new Promise(function (resolve, reject) {\r\n      loader.load(\r\n        resolveURL(bufferDef.uri, options.path),\r\n        resolve,\r\n        undefined,\r\n        function () {\r\n          reject(\r\n            new Error(\r\n              'THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'\r\n            )\r\n          );\r\n        }\r\n      );\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views\r\n   * @param {number} bufferViewIndex\r\n   * @return {Promise<ArrayBuffer>}\r\n   */\r\n  loadBufferView(bufferViewIndex) {\r\n    const bufferViewDef = this.json.bufferViews[bufferViewIndex];\r\n\r\n    return this.getDependency(\"buffer\", bufferViewDef.buffer).then(function (\r\n      buffer\r\n    ) {\r\n      const byteLength = bufferViewDef.byteLength || 0;\r\n      const byteOffset = bufferViewDef.byteOffset || 0;\r\n      return buffer.slice(byteOffset, byteOffset + byteLength);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors\r\n   * @param {number} accessorIndex\r\n   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}\r\n   */\r\n  loadAccessor(accessorIndex) {\r\n    const parser = this;\r\n    const json = this.json;\r\n\r\n    const accessorDef = this.json.accessors[accessorIndex];\r\n\r\n    if (\r\n      accessorDef.bufferView === undefined &&\r\n      accessorDef.sparse === undefined\r\n    ) {\r\n      // Ignore empty accessors, which may be used to declare runtime\r\n      // information about attributes coming from another source (e.g. Draco\r\n      // compression extension).\r\n      return Promise.resolve(null);\r\n    }\r\n\r\n    const pendingBufferViews = [];\r\n\r\n    if (accessorDef.bufferView !== undefined) {\r\n      pendingBufferViews.push(\r\n        this.getDependency(\"bufferView\", accessorDef.bufferView)\r\n      );\r\n    } else {\r\n      pendingBufferViews.push(null);\r\n    }\r\n\r\n    if (accessorDef.sparse !== undefined) {\r\n      pendingBufferViews.push(\r\n        this.getDependency(\"bufferView\", accessorDef.sparse.indices.bufferView)\r\n      );\r\n      pendingBufferViews.push(\r\n        this.getDependency(\"bufferView\", accessorDef.sparse.values.bufferView)\r\n      );\r\n    }\r\n\r\n    return Promise.all(pendingBufferViews).then(function (bufferViews) {\r\n      const bufferView = bufferViews[0];\r\n\r\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\r\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\r\n\r\n      // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\r\n      const elementBytes = TypedArray.BYTES_PER_ELEMENT;\r\n      const itemBytes = elementBytes * itemSize;\r\n      const byteOffset = accessorDef.byteOffset || 0;\r\n      const byteStride =\r\n        accessorDef.bufferView !== undefined\r\n          ? json.bufferViews[accessorDef.bufferView].byteStride\r\n          : undefined;\r\n      const normalized = accessorDef.normalized === true;\r\n      let array, bufferAttribute;\r\n\r\n      // The buffer is not interleaved if the stride is the item size in bytes.\r\n      if (byteStride && byteStride !== itemBytes) {\r\n        // Each \"slice\" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer\r\n        // This makes sure that IBA.count reflects accessor.count properly\r\n        const ibSlice = Math.floor(byteOffset / byteStride);\r\n        const ibCacheKey =\r\n          \"InterleavedBuffer:\" +\r\n          accessorDef.bufferView +\r\n          \":\" +\r\n          accessorDef.componentType +\r\n          \":\" +\r\n          ibSlice +\r\n          \":\" +\r\n          accessorDef.count;\r\n        let ib = parser.cache.get(ibCacheKey);\r\n\r\n        if (!ib) {\r\n          array = new TypedArray(\r\n            bufferView,\r\n            ibSlice * byteStride,\r\n            (accessorDef.count * byteStride) / elementBytes\r\n          );\r\n\r\n          // Integer parameters to IB/IBA are in array elements, not bytes.\r\n          ib = new InterleavedBuffer(array, byteStride / elementBytes);\r\n\r\n          parser.cache.add(ibCacheKey, ib);\r\n        }\r\n\r\n        bufferAttribute = new InterleavedBufferAttribute(\r\n          ib,\r\n          itemSize,\r\n          (byteOffset % byteStride) / elementBytes,\r\n          normalized\r\n        );\r\n      } else {\r\n        if (bufferView === null) {\r\n          array = new TypedArray(accessorDef.count * itemSize);\r\n        } else {\r\n          array = new TypedArray(\r\n            bufferView,\r\n            byteOffset,\r\n            accessorDef.count * itemSize\r\n          );\r\n        }\r\n\r\n        bufferAttribute = new BufferAttribute(array, itemSize, normalized);\r\n      }\r\n\r\n      // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors\r\n      if (accessorDef.sparse !== undefined) {\r\n        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\r\n        const TypedArrayIndices =\r\n          WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\r\n\r\n        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\r\n        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\r\n\r\n        const sparseIndices = new TypedArrayIndices(\r\n          bufferViews[1],\r\n          byteOffsetIndices,\r\n          accessorDef.sparse.count * itemSizeIndices\r\n        );\r\n        const sparseValues = new TypedArray(\r\n          bufferViews[2],\r\n          byteOffsetValues,\r\n          accessorDef.sparse.count * itemSize\r\n        );\r\n\r\n        if (bufferView !== null) {\r\n          // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.\r\n          bufferAttribute = new BufferAttribute(\r\n            bufferAttribute.array.slice(),\r\n            bufferAttribute.itemSize,\r\n            bufferAttribute.normalized\r\n          );\r\n        }\r\n\r\n        for (let i = 0, il = sparseIndices.length; i < il; i++) {\r\n          const index = sparseIndices[i];\r\n\r\n          bufferAttribute.setX(index, sparseValues[i * itemSize]);\r\n          if (itemSize >= 2)\r\n            bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\r\n          if (itemSize >= 3)\r\n            bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\r\n          if (itemSize >= 4)\r\n            bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\r\n          if (itemSize >= 5)\r\n            throw new Error(\r\n              \"THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.\"\r\n            );\r\n        }\r\n      }\r\n\r\n      return bufferAttribute;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures\r\n   * @param {number} textureIndex\r\n   * @return {Promise<THREE.Texture>}\r\n   */\r\n  loadTexture(textureIndex) {\r\n    const json = this.json;\r\n    const options = this.options;\r\n    const textureDef = json.textures[textureIndex];\r\n    const source = json.images[textureDef.source];\r\n\r\n    let loader = this.textureLoader;\r\n\r\n    if (source.uri) {\r\n      const handler = options.manager.getHandler(source.uri);\r\n      if (handler !== null) loader = handler;\r\n    }\r\n\r\n    return this.loadTextureImage(textureIndex, source, loader);\r\n  }\r\n\r\n  loadTextureImage(textureIndex, source, loader) {\r\n    const parser = this;\r\n    const json = this.json;\r\n    const options = this.options;\r\n\r\n    const textureDef = json.textures[textureIndex];\r\n\r\n    const cacheKey =\r\n      (source.uri || source.bufferView) + \":\" + textureDef.sampler;\r\n\r\n    if (this.textureCache[cacheKey]) {\r\n      // See https://github.com/mrdoob/three.js/issues/21559.\r\n      return this.textureCache[cacheKey];\r\n    }\r\n\r\n    const URL = this.URL || this.webkitURL;\r\n\r\n    let sourceURI = source.uri || \"\";\r\n    let isObjectURL = false;\r\n    let hasAlpha = true;\r\n\r\n    const isJPEG =\r\n      sourceURI.search(/\\.jpe?g($|\\?)/i) > 0 ||\r\n      sourceURI.search(/^data\\:image\\/jpeg/) === 0;\r\n\r\n    if (source.mimeType === \"image/jpeg\" || isJPEG) hasAlpha = false;\r\n\r\n    if (source.bufferView !== undefined) {\r\n      // Load binary image data from bufferView, if provided.\r\n\r\n      sourceURI = parser\r\n        .getDependency(\"bufferView\", source.bufferView)\r\n        .then(function (bufferView) {\r\n          if (source.mimeType === \"image/png\") {\r\n            // Inspect the PNG 'IHDR' chunk to determine whether the image could have an\r\n            // alpha channel. This check is conservative — the image could have an alpha\r\n            // channel with all values == 1, and the indexed type (colorType == 3) only\r\n            // sometimes contains alpha.\r\n            //\r\n            // https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header\r\n            const colorType = new DataView(bufferView, 25, 1).getUint8(0);\r\n            hasAlpha = colorType === 6 || colorType === 4 || colorType === 3;\r\n          }\r\n\r\n          isObjectURL = true;\r\n          const blob = new Blob([bufferView], { type: source.mimeType });\r\n          sourceURI = URL.createObjectURL(blob);\r\n          return sourceURI;\r\n        });\r\n    } else if (source.uri === undefined) {\r\n      throw new Error(\r\n        \"THREE.GLTFLoader: Image \" +\r\n          textureIndex +\r\n          \" is missing URI and bufferView\"\r\n      );\r\n    }\r\n\r\n    const promise = Promise.resolve(sourceURI)\r\n      .then(function (sourceURI) {\r\n        return new Promise(function (resolve, reject) {\r\n          let onLoad = resolve;\r\n\r\n          if (loader.isImageBitmapLoader === true) {\r\n            onLoad = function (imageBitmap: any) {\r\n              const texture = new Texture(imageBitmap);\r\n              texture.needsUpdate = true;\r\n\r\n              resolve(texture);\r\n            };\r\n          }\r\n\r\n          loader.load(\r\n            resolveURL(sourceURI, options.path),\r\n            onLoad,\r\n            undefined,\r\n            reject\r\n          );\r\n        });\r\n      })\r\n      .then(function (texture: any) {\r\n        // Clean up resources and configure Texture.\r\n\r\n        if (isObjectURL === true) {\r\n          URL.revokeObjectURL(sourceURI);\r\n        }\r\n\r\n        texture.flipY = false;\r\n\r\n        if (textureDef.name) texture.name = textureDef.name;\r\n\r\n        // When there is definitely no alpha channel in the texture, set RGBFormat to save space.\r\n        if (!hasAlpha) texture.format = RGBFormat;\r\n\r\n        const samplers = json.samplers || {};\r\n        const sampler = samplers[textureDef.sampler] || {};\r\n\r\n        texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;\r\n        texture.minFilter =\r\n          WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;\r\n        texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;\r\n        texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;\r\n\r\n        parser.associations.set(texture, {\r\n          type: \"textures\",\r\n          index: textureIndex,\r\n        });\r\n\r\n        return texture;\r\n      })\r\n      .catch(function () {\r\n        console.error(\"THREE.GLTFLoader: Couldn't load texture\", sourceURI);\r\n        return null;\r\n      });\r\n\r\n    this.textureCache[cacheKey] = promise;\r\n\r\n    return promise;\r\n  }\r\n\r\n  /**\r\n   * Asynchronously assigns a texture to the given material parameters.\r\n   * @param {Object} materialParams\r\n   * @param {string} mapName\r\n   * @param {Object} mapDef\r\n   * @return {Promise}\r\n   */\r\n  assignTexture(materialParams, mapName, mapDef) {\r\n    const parser = this;\r\n\r\n    return this.getDependency(\"texture\", mapDef.index).then(function (texture) {\r\n      // Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured\r\n      // However, we will copy UV set 0 to UV set 1 on demand for aoMap\r\n      if (\r\n        mapDef.texCoord !== undefined &&\r\n        mapDef.texCoord != 0 &&\r\n        !(mapName === \"aoMap\" && mapDef.texCoord == 1)\r\n      ) {\r\n        console.warn(\r\n          \"THREE.GLTFLoader: Custom UV set \" +\r\n            mapDef.texCoord +\r\n            \" for texture \" +\r\n            mapName +\r\n            \" not yet supported.\"\r\n        );\r\n      }\r\n\r\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\r\n        const transform =\r\n          mapDef.extensions !== undefined\r\n            ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]\r\n            : undefined;\r\n\r\n        if (transform) {\r\n          const gltfReference = parser.associations.get(texture);\r\n          texture = parser.extensions[\r\n            EXTENSIONS.KHR_TEXTURE_TRANSFORM\r\n          ].extendTexture(texture, transform);\r\n          parser.associations.set(texture, gltfReference);\r\n        }\r\n      }\r\n\r\n      materialParams[mapName] = texture;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Assigns final material to a Mesh, Line, or Points instance. The instance\r\n   * already has a material (generated from the glTF material options alone)\r\n   * but reuse of the same glTF material may require multiple threejs materials\r\n   * to accommodate different primitive types, defines, etc. New materials will\r\n   * be created if necessary, and reused from a cache.\r\n   * @param  {Object3D} mesh Mesh, Line, or Points instance.\r\n   */\r\n  assignFinalMaterial(mesh) {\r\n    const geometry = mesh.geometry;\r\n    let material = mesh.material;\r\n\r\n    const useVertexTangents = geometry.attributes.tangent !== undefined;\r\n    const useVertexColors = geometry.attributes.color !== undefined;\r\n    const useFlatShading = geometry.attributes.normal === undefined;\r\n    const useMorphTargets = Object.keys(geometry.morphAttributes).length > 0;\r\n    const useMorphNormals =\r\n      useMorphTargets && geometry.morphAttributes.normal !== undefined;\r\n\r\n    if (mesh.isPoints) {\r\n      const cacheKey = \"PointsMaterial:\" + material.uuid;\r\n\r\n      let pointsMaterial = this.cache.get(cacheKey);\r\n\r\n      if (!pointsMaterial) {\r\n        pointsMaterial = new PointsMaterial();\r\n        Material.prototype.copy.call(pointsMaterial, material);\r\n        pointsMaterial.color.copy(material.color);\r\n        pointsMaterial.map = material.map;\r\n        pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px\r\n\r\n        this.cache.add(cacheKey, pointsMaterial);\r\n      }\r\n\r\n      material = pointsMaterial;\r\n    } else if (mesh.isLine) {\r\n      const cacheKey = \"LineBasicMaterial:\" + material.uuid;\r\n\r\n      let lineMaterial = this.cache.get(cacheKey);\r\n\r\n      if (!lineMaterial) {\r\n        lineMaterial = new LineBasicMaterial();\r\n        Material.prototype.copy.call(lineMaterial, material);\r\n        lineMaterial.color.copy(material.color);\r\n\r\n        this.cache.add(cacheKey, lineMaterial);\r\n      }\r\n\r\n      material = lineMaterial;\r\n    }\r\n\r\n    // Clone the material if it will be modified\r\n    if (\r\n      useVertexTangents ||\r\n      useVertexColors ||\r\n      useFlatShading ||\r\n      useMorphTargets\r\n    ) {\r\n      let cacheKey = \"ClonedMaterial:\" + material.uuid + \":\";\r\n\r\n      if (material.isGLTFSpecularGlossinessMaterial)\r\n        cacheKey += \"specular-glossiness:\";\r\n      if (useVertexTangents) cacheKey += \"vertex-tangents:\";\r\n      if (useVertexColors) cacheKey += \"vertex-colors:\";\r\n      if (useFlatShading) cacheKey += \"flat-shading:\";\r\n      if (useMorphTargets) cacheKey += \"morph-targets:\";\r\n      if (useMorphNormals) cacheKey += \"morph-normals:\";\r\n\r\n      let cachedMaterial = this.cache.get(cacheKey);\r\n\r\n      if (!cachedMaterial) {\r\n        cachedMaterial = material.clone();\r\n\r\n        if (useVertexColors) cachedMaterial.vertexColors = true;\r\n        if (useFlatShading) cachedMaterial.flatShading = true;\r\n        if (useMorphTargets) cachedMaterial.morphTargets = true;\r\n        if (useMorphNormals) cachedMaterial.morphNormals = true;\r\n\r\n        if (useVertexTangents) {\r\n          cachedMaterial.vertexTangents = true;\r\n\r\n          // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\r\n          if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;\r\n          if (cachedMaterial.clearcoatNormalScale)\r\n            cachedMaterial.clearcoatNormalScale.y *= -1;\r\n        }\r\n\r\n        this.cache.add(cacheKey, cachedMaterial);\r\n\r\n        this.associations.set(cachedMaterial, this.associations.get(material));\r\n      }\r\n\r\n      material = cachedMaterial;\r\n    }\r\n\r\n    // workarounds for mesh and geometry\r\n\r\n    if (\r\n      material.aoMap &&\r\n      geometry.attributes.uv2 === undefined &&\r\n      geometry.attributes.uv !== undefined\r\n    ) {\r\n      geometry.setAttribute(\"uv2\", geometry.attributes.uv);\r\n    }\r\n\r\n    mesh.material = material;\r\n  }\r\n\r\n  getMaterialType(/* materialIndex */) {\r\n    return MeshStandardMaterial;\r\n  }\r\n\r\n  /**\r\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials\r\n   * @param {number} materialIndex\r\n   * @return {Promise<Material>}\r\n   */\r\n  loadMaterial(materialIndex) {\r\n    const parser = this;\r\n    const json = this.json;\r\n    const extensions = this.extensions;\r\n    const materialDef = json.materials[materialIndex];\r\n\r\n    let materialType;\r\n    const materialParams: any = {};\r\n    const materialExtensions: any = materialDef.extensions || {};\r\n\r\n    const pending = [];\r\n\r\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {\r\n      const sgExtension =\r\n        extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\r\n      materialType = sgExtension.getMaterialType();\r\n      pending.push(\r\n        sgExtension.extendParams(materialParams, materialDef, parser)\r\n      );\r\n    } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\r\n      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\r\n      materialType = kmuExtension.getMaterialType();\r\n      pending.push(\r\n        kmuExtension.extendParams(materialParams, materialDef, parser)\r\n      );\r\n    } else {\r\n      // Specification:\r\n      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material\r\n\r\n      const metallicRoughness = materialDef.pbrMetallicRoughness || {};\r\n\r\n      materialParams.color = new Color(1.0, 1.0, 1.0);\r\n      materialParams.opacity = 1.0;\r\n\r\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\r\n        const array = metallicRoughness.baseColorFactor;\r\n\r\n        materialParams.color.fromArray(array);\r\n        materialParams.opacity = array[3];\r\n      }\r\n\r\n      if (metallicRoughness.baseColorTexture !== undefined) {\r\n        pending.push(\r\n          parser.assignTexture(\r\n            materialParams,\r\n            \"map\",\r\n            metallicRoughness.baseColorTexture\r\n          )\r\n        );\r\n      }\r\n\r\n      materialParams.metalness =\r\n        metallicRoughness.metallicFactor !== undefined\r\n          ? metallicRoughness.metallicFactor\r\n          : 1.0;\r\n      materialParams.roughness =\r\n        metallicRoughness.roughnessFactor !== undefined\r\n          ? metallicRoughness.roughnessFactor\r\n          : 1.0;\r\n\r\n      if (metallicRoughness.metallicRoughnessTexture !== undefined) {\r\n        pending.push(\r\n          parser.assignTexture(\r\n            materialParams,\r\n            \"metalnessMap\",\r\n            metallicRoughness.metallicRoughnessTexture\r\n          )\r\n        );\r\n        pending.push(\r\n          parser.assignTexture(\r\n            materialParams,\r\n            \"roughnessMap\",\r\n            metallicRoughness.metallicRoughnessTexture\r\n          )\r\n        );\r\n      }\r\n\r\n      materialType = this._invokeOne(function (ext) {\r\n        return ext.getMaterialType && ext.getMaterialType(materialIndex);\r\n      });\r\n\r\n      pending.push(\r\n        Promise.all(\r\n          this._invokeAll(function (ext) {\r\n            return (\r\n              ext.extendMaterialParams &&\r\n              ext.extendMaterialParams(materialIndex, materialParams)\r\n            );\r\n          })\r\n        )\r\n      );\r\n    }\r\n\r\n    if (materialDef.doubleSided === true) {\r\n      materialParams.side = DoubleSide;\r\n    }\r\n\r\n    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\r\n\r\n    if (alphaMode === ALPHA_MODES.BLEND) {\r\n      materialParams.transparent = true;\r\n\r\n      // See: https://github.com/mrdoob/three.js/issues/17706\r\n      materialParams.depthWrite = false;\r\n    } else {\r\n      materialParams.transparent = false;\r\n\r\n      if (alphaMode === ALPHA_MODES.MASK) {\r\n        materialParams.alphaTest =\r\n          materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;\r\n      }\r\n    }\r\n\r\n    if (\r\n      materialDef.normalTexture !== undefined &&\r\n      materialType !== MeshBasicMaterial\r\n    ) {\r\n      pending.push(\r\n        parser.assignTexture(\r\n          materialParams,\r\n          \"normalMap\",\r\n          materialDef.normalTexture\r\n        )\r\n      );\r\n\r\n      // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\r\n      materialParams.normalScale = new Vector2(1, -1);\r\n\r\n      if (materialDef.normalTexture.scale !== undefined) {\r\n        materialParams.normalScale.set(\r\n          materialDef.normalTexture.scale,\r\n          -materialDef.normalTexture.scale\r\n        );\r\n      }\r\n    }\r\n\r\n    if (\r\n      materialDef.occlusionTexture !== undefined &&\r\n      materialType !== MeshBasicMaterial\r\n    ) {\r\n      pending.push(\r\n        parser.assignTexture(\r\n          materialParams,\r\n          \"aoMap\",\r\n          materialDef.occlusionTexture\r\n        )\r\n      );\r\n\r\n      if (materialDef.occlusionTexture.strength !== undefined) {\r\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\r\n      }\r\n    }\r\n\r\n    if (\r\n      materialDef.emissiveFactor !== undefined &&\r\n      materialType !== MeshBasicMaterial\r\n    ) {\r\n      materialParams.emissive = new Color().fromArray(\r\n        materialDef.emissiveFactor\r\n      );\r\n    }\r\n\r\n    if (\r\n      materialDef.emissiveTexture !== undefined &&\r\n      materialType !== MeshBasicMaterial\r\n    ) {\r\n      pending.push(\r\n        parser.assignTexture(\r\n          materialParams,\r\n          \"emissiveMap\",\r\n          materialDef.emissiveTexture\r\n        )\r\n      );\r\n    }\r\n\r\n    return Promise.all(pending).then(function () {\r\n      let material;\r\n\r\n      if (materialType === GLTFMeshStandardSGMaterial) {\r\n        material = extensions[\r\n          EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS\r\n        ].createMaterial(materialParams);\r\n      } else {\r\n        material = new materialType(materialParams);\r\n      }\r\n\r\n      if (materialDef.name) material.name = materialDef.name;\r\n\r\n      // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.\r\n      if (material.map) material.map.encoding = sRGBEncoding;\r\n      if (material.emissiveMap) material.emissiveMap.encoding = sRGBEncoding;\r\n\r\n      assignExtrasToUserData(material, materialDef);\r\n\r\n      parser.associations.set(material, {\r\n        type: \"materials\",\r\n        index: materialIndex,\r\n      });\r\n\r\n      if (materialDef.extensions)\r\n        addUnknownExtensionsToUserData(extensions, material, materialDef);\r\n\r\n      return material;\r\n    });\r\n  }\r\n\r\n  /** When Object3D instances are targeted by animation, they need unique names. */\r\n  createUniqueName(originalName) {\r\n    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || \"\");\r\n\r\n    let name = sanitizedName;\r\n\r\n    for (let i = 1; this.nodeNamesUsed[name]; ++i) {\r\n      name = sanitizedName + \"_\" + i;\r\n    }\r\n\r\n    this.nodeNamesUsed[name] = true;\r\n\r\n    return name;\r\n  }\r\n\r\n  /**\r\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry\r\n   *\r\n   * Creates BufferGeometries from primitives.\r\n   *\r\n   * @param {Array<GLTF.Primitive>} primitives\r\n   * @return {Promise<Array<BufferGeometry>>}\r\n   */\r\n  loadGeometries(primitives) {\r\n    const parser = this;\r\n    const extensions = this.extensions;\r\n    const cache = this.primitiveCache;\r\n\r\n    function createDracoPrimitive(primitive) {\r\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]\r\n        .decodePrimitive(primitive, parser)\r\n        .then(function (geometry) {\r\n          return addPrimitiveAttributes(geometry, primitive, parser);\r\n        });\r\n    }\r\n\r\n    const pending = [];\r\n\r\n    for (let i = 0, il = primitives.length; i < il; i++) {\r\n      const primitive = primitives[i];\r\n      const cacheKey = createPrimitiveKey(primitive);\r\n\r\n      // See if we've already created this geometry\r\n      const cached = cache[cacheKey];\r\n\r\n      if (cached) {\r\n        // Use the cached geometry if it exists\r\n        pending.push(cached.promise);\r\n      } else {\r\n        let geometryPromise;\r\n\r\n        if (\r\n          primitive.extensions &&\r\n          primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]\r\n        ) {\r\n          // Use DRACO geometry if available\r\n          geometryPromise = createDracoPrimitive(primitive);\r\n        } else {\r\n          // Otherwise create a new geometry\r\n          geometryPromise = addPrimitiveAttributes(\r\n            new BufferGeometry(),\r\n            primitive,\r\n            parser\r\n          );\r\n        }\r\n\r\n        // Cache this geometry\r\n        cache[cacheKey] = { primitive: primitive, promise: geometryPromise };\r\n\r\n        pending.push(geometryPromise);\r\n      }\r\n    }\r\n\r\n    return Promise.all(pending);\r\n  }\r\n\r\n  /**\r\n   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes\r\n   * @param {number} meshIndex\r\n   * @return {Promise<Group|Mesh|SkinnedMesh>}\r\n   */\r\n  loadMesh(meshIndex) {\r\n    const parser = this;\r\n    const json = this.json;\r\n    const extensions = this.extensions;\r\n\r\n    const meshDef = json.meshes[meshIndex];\r\n    const primitives = meshDef.primitives;\r\n\r\n    const pending = [];\r\n\r\n    for (let i = 0, il = primitives.length; i < il; i++) {\r\n      const material =\r\n        primitives[i].material === undefined\r\n          ? createDefaultMaterial(this.cache)\r\n          : this.getDependency(\"material\", primitives[i].material);\r\n\r\n      pending.push(material);\r\n    }\r\n\r\n    pending.push(parser.loadGeometries(primitives));\r\n\r\n    return Promise.all(pending).then(function (results) {\r\n      const materials = results.slice(0, results.length - 1);\r\n      const geometries = results[results.length - 1];\r\n\r\n      const meshes = [];\r\n\r\n      for (let i = 0, il = geometries.length; i < il; i++) {\r\n        const geometry = geometries[i];\r\n        const primitive = primitives[i];\r\n\r\n        // 1. create Mesh\r\n\r\n        let mesh;\r\n\r\n        const material = materials[i];\r\n\r\n        if (\r\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||\r\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||\r\n          primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||\r\n          primitive.mode === undefined\r\n        ) {\r\n          // .isSkinnedMesh isn't in glTF spec. See ._markDefs()\r\n          mesh =\r\n            meshDef.isSkinnedMesh === true\r\n              ? new SkinnedMesh(geometry, material)\r\n              : new Mesh(geometry, material);\r\n\r\n          if (\r\n            mesh.isSkinnedMesh === true &&\r\n            !mesh.geometry.attributes.skinWeight.normalized\r\n          ) {\r\n            // we normalize floating point skin weight array to fix malformed assets (see #15319)\r\n            // it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs\r\n            mesh.normalizeSkinWeights();\r\n          }\r\n\r\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\r\n            mesh.geometry = toTrianglesDrawMode(\r\n              mesh.geometry,\r\n              TriangleStripDrawMode\r\n            );\r\n          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\r\n            mesh.geometry = toTrianglesDrawMode(\r\n              mesh.geometry,\r\n              TriangleFanDrawMode\r\n            );\r\n          }\r\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\r\n          mesh = new LineSegments(geometry, material);\r\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\r\n          mesh = new Line(geometry, material);\r\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\r\n          mesh = new LineLoop(geometry, material);\r\n        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\r\n          mesh = new Points(geometry, material);\r\n        } else {\r\n          throw new Error(\r\n            \"THREE.GLTFLoader: Primitive mode unsupported: \" + primitive.mode\r\n          );\r\n        }\r\n\r\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\r\n          updateMorphTargets(mesh, meshDef);\r\n        }\r\n\r\n        mesh.name = parser.createUniqueName(\r\n          meshDef.name || \"mesh_\" + meshIndex\r\n        );\r\n\r\n        assignExtrasToUserData(mesh, meshDef);\r\n\r\n        if (primitive.extensions)\r\n          addUnknownExtensionsToUserData(extensions, mesh, primitive);\r\n\r\n        parser.assignFinalMaterial(mesh);\r\n\r\n        meshes.push(mesh);\r\n      }\r\n\r\n      if (meshes.length === 1) {\r\n        return meshes[0];\r\n      }\r\n\r\n      const group = new Group();\r\n\r\n      for (let i = 0, il = meshes.length; i < il; i++) {\r\n        group.add(meshes[i]);\r\n      }\r\n\r\n      return group;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras\r\n   * @param {number} cameraIndex\r\n   * @return {Promise<THREE.Camera>}\r\n   */\r\n  loadCamera(cameraIndex) {\r\n    let camera;\r\n    const cameraDef = this.json.cameras[cameraIndex];\r\n    const params = cameraDef[cameraDef.type];\r\n\r\n    if (!params) {\r\n      console.warn(\"THREE.GLTFLoader: Missing camera parameters.\");\r\n      return;\r\n    }\r\n\r\n    if (cameraDef.type === \"perspective\") {\r\n      camera = new PerspectiveCamera(\r\n        MathUtils.radToDeg(params.yfov),\r\n        params.aspectRatio || 1,\r\n        params.znear || 1,\r\n        params.zfar || 2e6\r\n      );\r\n    } else if (cameraDef.type === \"orthographic\") {\r\n      camera = new OrthographicCamera(\r\n        -params.xmag,\r\n        params.xmag,\r\n        params.ymag,\r\n        -params.ymag,\r\n        params.znear,\r\n        params.zfar\r\n      );\r\n    }\r\n\r\n    if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);\r\n\r\n    assignExtrasToUserData(camera, cameraDef);\r\n\r\n    return Promise.resolve(camera);\r\n  }\r\n\r\n  /**\r\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins\r\n   * @param {number} skinIndex\r\n   * @return {Promise<Object>}\r\n   */\r\n  loadSkin(skinIndex) {\r\n    const skinDef = this.json.skins[skinIndex];\r\n\r\n    const skinEntry = { joints: skinDef.joints } as any;\r\n\r\n    if (skinDef.inverseBindMatrices === undefined) {\r\n      return Promise.resolve(skinEntry);\r\n    }\r\n\r\n    return this.getDependency(\"accessor\", skinDef.inverseBindMatrices).then(\r\n      function (accessor) {\r\n        skinEntry.inverseBindMatrices = accessor;\r\n\r\n        return skinEntry;\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\r\n   * @param {number} animationIndex\r\n   * @return {Promise<AnimationClip>}\r\n   */\r\n  loadAnimation(animationIndex) {\r\n    const json = this.json;\r\n\r\n    const animationDef = json.animations[animationIndex];\r\n\r\n    const pendingNodes = [];\r\n    const pendingInputAccessors = [];\r\n    const pendingOutputAccessors = [];\r\n    const pendingSamplers = [];\r\n    const pendingTargets = [];\r\n\r\n    for (let i = 0, il = animationDef.channels.length; i < il; i++) {\r\n      const channel = animationDef.channels[i];\r\n      const sampler = animationDef.samplers[channel.sampler];\r\n      const target = channel.target;\r\n      const name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.\r\n      const input =\r\n        animationDef.parameters !== undefined\r\n          ? animationDef.parameters[sampler.input]\r\n          : sampler.input;\r\n      const output =\r\n        animationDef.parameters !== undefined\r\n          ? animationDef.parameters[sampler.output]\r\n          : sampler.output;\r\n\r\n      pendingNodes.push(this.getDependency(\"node\", name));\r\n      pendingInputAccessors.push(this.getDependency(\"accessor\", input));\r\n      pendingOutputAccessors.push(this.getDependency(\"accessor\", output));\r\n      pendingSamplers.push(sampler);\r\n      pendingTargets.push(target);\r\n    }\r\n\r\n    return Promise.all([\r\n      Promise.all(pendingNodes),\r\n      Promise.all(pendingInputAccessors),\r\n      Promise.all(pendingOutputAccessors),\r\n      Promise.all(pendingSamplers),\r\n      Promise.all(pendingTargets),\r\n    ]).then(function (dependencies) {\r\n      const nodes = dependencies[0];\r\n      const inputAccessors = dependencies[1];\r\n      const outputAccessors = dependencies[2];\r\n      const samplers = dependencies[3];\r\n      const targets = dependencies[4];\r\n\r\n      const tracks = [];\r\n\r\n      for (let i = 0, il = nodes.length; i < il; i++) {\r\n        const node = nodes[i];\r\n        const inputAccessor = inputAccessors[i];\r\n        const outputAccessor = outputAccessors[i];\r\n        const sampler = samplers[i];\r\n        const target = targets[i];\r\n\r\n        if (node === undefined) continue;\r\n\r\n        node.updateMatrix();\r\n        node.matrixAutoUpdate = true;\r\n\r\n        let TypedKeyframeTrack;\r\n\r\n        switch (PATH_PROPERTIES[target.path]) {\r\n          case PATH_PROPERTIES.weights:\r\n            TypedKeyframeTrack = NumberKeyframeTrack;\r\n            break;\r\n\r\n          case PATH_PROPERTIES.rotation:\r\n            TypedKeyframeTrack = QuaternionKeyframeTrack;\r\n            break;\r\n\r\n          case PATH_PROPERTIES.position:\r\n          case PATH_PROPERTIES.scale:\r\n          default:\r\n            TypedKeyframeTrack = VectorKeyframeTrack;\r\n            break;\r\n        }\r\n\r\n        const targetName = node.name ? node.name : node.uuid;\r\n\r\n        const interpolation =\r\n          sampler.interpolation !== undefined\r\n            ? INTERPOLATION[sampler.interpolation]\r\n            : InterpolateLinear;\r\n\r\n        const targetNames = [];\r\n\r\n        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\r\n          // Node may be a Group (glTF mesh with several primitives) or a Mesh.\r\n          node.traverse(function (object) {\r\n            if (object.isMesh === true && object.morphTargetInfluences) {\r\n              targetNames.push(object.name ? object.name : object.uuid);\r\n            }\r\n          });\r\n        } else {\r\n          targetNames.push(targetName);\r\n        }\r\n\r\n        let outputArray = outputAccessor.array;\r\n\r\n        if (outputAccessor.normalized) {\r\n          const scale = getNormalizedComponentScale(outputArray.constructor);\r\n          const scaled = new Float32Array(outputArray.length);\r\n\r\n          for (let j = 0, jl = outputArray.length; j < jl; j++) {\r\n            scaled[j] = outputArray[j] * scale;\r\n          }\r\n\r\n          outputArray = scaled;\r\n        }\r\n\r\n        for (let j = 0, jl = targetNames.length; j < jl; j++) {\r\n          const track = new TypedKeyframeTrack(\r\n            targetNames[j] + \".\" + PATH_PROPERTIES[target.path],\r\n            inputAccessor.array,\r\n            outputArray,\r\n            interpolation\r\n          );\r\n\r\n          // Override interpolation with custom factory method.\r\n          if (sampler.interpolation === \"CUBICSPLINE\") {\r\n            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(\r\n              result\r\n            ) {\r\n              // A CUBICSPLINE keyframe in glTF has three output values for each input value,\r\n              // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()\r\n              // must be divided by three to get the interpolant's sampleSize argument.\r\n\r\n              return new GLTFCubicSplineInterpolant(\r\n                this.times,\r\n                this.values,\r\n                this.getValueSize() / 3,\r\n                result\r\n              );\r\n            };\r\n\r\n            // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.\r\n            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\r\n          }\r\n\r\n          tracks.push(track);\r\n        }\r\n      }\r\n\r\n      const name = animationDef.name\r\n        ? animationDef.name\r\n        : \"animation_\" + animationIndex;\r\n\r\n      return new AnimationClip(name, undefined, tracks);\r\n    });\r\n  }\r\n\r\n  createNodeMesh(nodeIndex) {\r\n    const json = this.json;\r\n    const parser = this;\r\n    const nodeDef = json.nodes[nodeIndex];\r\n\r\n    if (nodeDef.mesh === undefined) return null;\r\n\r\n    return parser.getDependency(\"mesh\", nodeDef.mesh).then(function (mesh) {\r\n      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);\r\n\r\n      // if weights are provided on the node, override weights on the mesh.\r\n      if (nodeDef.weights !== undefined) {\r\n        node.traverse(function (o) {\r\n          if (!o.isMesh) return;\r\n\r\n          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {\r\n            o.morphTargetInfluences[i] = nodeDef.weights[i];\r\n          }\r\n        });\r\n      }\r\n\r\n      return node;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy\r\n   * @param {number} nodeIndex\r\n   * @return {Promise<Object3D>}\r\n   */\r\n  loadNode(nodeIndex) {\r\n    const json = this.json;\r\n    const extensions = this.extensions;\r\n    const parser = this;\r\n\r\n    const nodeDef = json.nodes[nodeIndex];\r\n\r\n    // reserve node's name before its dependencies, so the root has the intended name.\r\n    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : \"\";\r\n\r\n    return (function () {\r\n      const pending = [];\r\n\r\n      const meshPromise = parser._invokeOne(function (ext) {\r\n        return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\r\n      });\r\n\r\n      if (meshPromise) {\r\n        pending.push(meshPromise);\r\n      }\r\n\r\n      if (nodeDef.camera !== undefined) {\r\n        pending.push(\r\n          parser\r\n            .getDependency(\"camera\", nodeDef.camera)\r\n            .then(function (camera) {\r\n              return parser._getNodeRef(\r\n                parser.cameraCache,\r\n                nodeDef.camera,\r\n                camera\r\n              );\r\n            })\r\n        );\r\n      }\r\n\r\n      parser\r\n        ._invokeAll(function (ext) {\r\n          return (\r\n            ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex)\r\n          );\r\n        })\r\n        .forEach(function (promise) {\r\n          pending.push(promise);\r\n        });\r\n\r\n      return Promise.all(pending);\r\n    })().then(function (objects) {\r\n      let node;\r\n\r\n      // .isBone isn't in glTF spec. See ._markDefs\r\n      if (nodeDef.isBone === true) {\r\n        node = new Bone();\r\n      } else if (objects.length > 1) {\r\n        node = new Group();\r\n      } else if (objects.length === 1) {\r\n        node = objects[0];\r\n      } else {\r\n        node = new Object3D();\r\n      }\r\n\r\n      if (node !== objects[0]) {\r\n        for (let i = 0, il = objects.length; i < il; i++) {\r\n          node.add(objects[i]);\r\n        }\r\n      }\r\n\r\n      if (nodeDef.name) {\r\n        node.userData.name = nodeDef.name;\r\n        node.name = nodeName;\r\n      }\r\n\r\n      assignExtrasToUserData(node, nodeDef);\r\n\r\n      if (nodeDef.extensions)\r\n        addUnknownExtensionsToUserData(extensions, node, nodeDef);\r\n\r\n      if (nodeDef.matrix !== undefined) {\r\n        const matrix = new Matrix4();\r\n        matrix.fromArray(nodeDef.matrix);\r\n        node.applyMatrix4(matrix);\r\n      } else {\r\n        if (nodeDef.translation !== undefined) {\r\n          node.position.fromArray(nodeDef.translation);\r\n        }\r\n\r\n        if (nodeDef.rotation !== undefined) {\r\n          node.quaternion.fromArray(nodeDef.rotation);\r\n        }\r\n\r\n        if (nodeDef.scale !== undefined) {\r\n          node.scale.fromArray(nodeDef.scale);\r\n        }\r\n      }\r\n\r\n      parser.associations.set(node, { type: \"nodes\", index: nodeIndex });\r\n\r\n      return node;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes\r\n   * @param {number} sceneIndex\r\n   * @return {Promise<Group>}\r\n   */\r\n  loadScene(sceneIndex) {\r\n    const json = this.json;\r\n    const extensions = this.extensions;\r\n    const sceneDef = this.json.scenes[sceneIndex];\r\n    const parser = this;\r\n\r\n    // Loader returns Group, not Scene.\r\n    // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172\r\n    const scene = new Group();\r\n    if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);\r\n\r\n    assignExtrasToUserData(scene, sceneDef);\r\n\r\n    if (sceneDef.extensions)\r\n      addUnknownExtensionsToUserData(extensions, scene, sceneDef);\r\n\r\n    const nodeIds = sceneDef.nodes || [];\r\n\r\n    const pending = [];\r\n\r\n    for (let i = 0, il = nodeIds.length; i < il; i++) {\r\n      pending.push(buildNodeHierachy(nodeIds[i], scene, json, parser));\r\n    }\r\n\r\n    return Promise.all(pending).then(function () {\r\n      return scene;\r\n    });\r\n  }\r\n}\r\n\r\nfunction buildNodeHierachy(nodeId, parentObject, json, parser) {\r\n  const nodeDef = json.nodes[nodeId];\r\n\r\n  return parser\r\n    .getDependency(\"node\", nodeId)\r\n    .then(function (node) {\r\n      if (nodeDef.skin === undefined) return node;\r\n\r\n      // build skeleton here as well\r\n\r\n      let skinEntry;\r\n\r\n      return parser\r\n        .getDependency(\"skin\", nodeDef.skin)\r\n        .then(function (skin) {\r\n          skinEntry = skin;\r\n\r\n          const pendingJoints = [];\r\n\r\n          for (let i = 0, il = skinEntry.joints.length; i < il; i++) {\r\n            pendingJoints.push(\r\n              parser.getDependency(\"node\", skinEntry.joints[i])\r\n            );\r\n          }\r\n\r\n          return Promise.all(pendingJoints);\r\n        })\r\n        .then(function (jointNodes) {\r\n          node.traverse(function (mesh) {\r\n            if (!mesh.isMesh) return;\r\n\r\n            const bones = [];\r\n            const boneInverses = [];\r\n\r\n            for (let j = 0, jl = jointNodes.length; j < jl; j++) {\r\n              const jointNode = jointNodes[j];\r\n\r\n              if (jointNode) {\r\n                bones.push(jointNode);\r\n\r\n                const mat = new Matrix4();\r\n\r\n                if (skinEntry.inverseBindMatrices !== undefined) {\r\n                  mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);\r\n                }\r\n\r\n                boneInverses.push(mat);\r\n              } else {\r\n                console.warn(\r\n                  'THREE.GLTFLoader: Joint \"%s\" could not be found.',\r\n                  skinEntry.joints[j]\r\n                );\r\n              }\r\n            }\r\n\r\n            mesh.bind(new Skeleton(bones, boneInverses), mesh.matrixWorld);\r\n          });\r\n\r\n          return node;\r\n        });\r\n    })\r\n    .then(function (node) {\r\n      // build node hierachy\r\n\r\n      parentObject.add(node);\r\n\r\n      const pending = [];\r\n\r\n      if (nodeDef.children) {\r\n        const children = nodeDef.children;\r\n\r\n        for (let i = 0, il = children.length; i < il; i++) {\r\n          const child = children[i];\r\n          pending.push(buildNodeHierachy(child, node, json, parser));\r\n        }\r\n      }\r\n\r\n      return Promise.all(pending);\r\n    });\r\n}\r\n\r\n/**\r\n * @param {BufferGeometry} geometry\r\n * @param {GLTF.Primitive} primitiveDef\r\n * @param {GLTFParser} parser\r\n */\r\nfunction computeBounds(geometry, primitiveDef, parser) {\r\n  const attributes = primitiveDef.attributes;\r\n\r\n  const box = new Box3();\r\n\r\n  if (attributes.POSITION !== undefined) {\r\n    const accessor = parser.json.accessors[attributes.POSITION];\r\n\r\n    const min = accessor.min;\r\n    const max = accessor.max;\r\n\r\n    // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\r\n\r\n    if (min !== undefined && max !== undefined) {\r\n      box.set(\r\n        new Vector3(min[0], min[1], min[2]),\r\n        new Vector3(max[0], max[1], max[2])\r\n      );\r\n\r\n      if (accessor.normalized) {\r\n        const boxScale = getNormalizedComponentScale(\r\n          WEBGL_COMPONENT_TYPES[accessor.componentType]\r\n        );\r\n        box.min.multiplyScalar(boxScale);\r\n        box.max.multiplyScalar(boxScale);\r\n      }\r\n    } else {\r\n      console.warn(\r\n        \"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\"\r\n      );\r\n\r\n      return;\r\n    }\r\n  } else {\r\n    return;\r\n  }\r\n\r\n  const targets = primitiveDef.targets;\r\n\r\n  if (targets !== undefined) {\r\n    const maxDisplacement = new Vector3();\r\n    const vector = new Vector3();\r\n\r\n    for (let i = 0, il = targets.length; i < il; i++) {\r\n      const target = targets[i];\r\n\r\n      if (target.POSITION !== undefined) {\r\n        const accessor = parser.json.accessors[target.POSITION];\r\n        const min = accessor.min;\r\n        const max = accessor.max;\r\n\r\n        // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.\r\n\r\n        if (min !== undefined && max !== undefined) {\r\n          // we need to get max of absolute components because target weight is [-1,1]\r\n          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\r\n          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\r\n          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\r\n\r\n          if (accessor.normalized) {\r\n            const boxScale = getNormalizedComponentScale(\r\n              WEBGL_COMPONENT_TYPES[accessor.componentType]\r\n            );\r\n            vector.multiplyScalar(boxScale);\r\n          }\r\n\r\n          // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative\r\n          // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets\r\n          // are used to implement key-frame animations and as such only two are active at a time - this results in very large\r\n          // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.\r\n          maxDisplacement.max(vector);\r\n        } else {\r\n          console.warn(\r\n            \"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\"\r\n          );\r\n        }\r\n      }\r\n    }\r\n\r\n    // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.\r\n    box.expandByVector(maxDisplacement);\r\n  }\r\n\r\n  geometry.boundingBox = box;\r\n\r\n  const sphere = new Sphere();\r\n\r\n  box.getCenter(sphere.center);\r\n  sphere.radius = box.min.distanceTo(box.max) / 2;\r\n\r\n  geometry.boundingSphere = sphere;\r\n}\r\n\r\n/**\r\n * @param {BufferGeometry} geometry\r\n * @param {GLTF.Primitive} primitiveDef\r\n * @param {GLTFParser} parser\r\n * @return {Promise<BufferGeometry>}\r\n */\r\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\r\n  const attributes = primitiveDef.attributes;\r\n\r\n  const pending = [];\r\n\r\n  function assignAttributeAccessor(accessorIndex, attributeName) {\r\n    return parser\r\n      .getDependency(\"accessor\", accessorIndex)\r\n      .then(function (accessor) {\r\n        geometry.setAttribute(attributeName, accessor);\r\n      });\r\n  }\r\n\r\n  for (const gltfAttributeName in attributes) {\r\n    const threeAttributeName =\r\n      ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();\r\n\r\n    // Skip attributes already provided by e.g. Draco extension.\r\n    if (threeAttributeName in geometry.attributes) continue;\r\n\r\n    pending.push(\r\n      assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName)\r\n    );\r\n  }\r\n\r\n  if (primitiveDef.indices !== undefined && !geometry.index) {\r\n    const accessor = parser\r\n      .getDependency(\"accessor\", primitiveDef.indices)\r\n      .then(function (accessor) {\r\n        geometry.setIndex(accessor);\r\n      });\r\n\r\n    pending.push(accessor);\r\n  }\r\n\r\n  assignExtrasToUserData(geometry, primitiveDef);\r\n\r\n  computeBounds(geometry, primitiveDef, parser);\r\n\r\n  return Promise.all(pending).then(function () {\r\n    return primitiveDef.targets !== undefined\r\n      ? addMorphTargets(geometry, primitiveDef.targets, parser)\r\n      : geometry;\r\n  });\r\n}\r\n\r\n/**\r\n * @param {BufferGeometry} geometry\r\n * @param {Number} drawMode\r\n * @return {BufferGeometry}\r\n */\r\nfunction toTrianglesDrawMode(geometry, drawMode) {\r\n  let index = geometry.getIndex();\r\n\r\n  // generate index if not present\r\n\r\n  if (index === null) {\r\n    const indices = [];\r\n\r\n    const position = geometry.getAttribute(\"position\");\r\n\r\n    if (position !== undefined) {\r\n      for (let i = 0; i < position.count; i++) {\r\n        indices.push(i);\r\n      }\r\n\r\n      geometry.setIndex(indices);\r\n      index = geometry.getIndex();\r\n    } else {\r\n      console.error(\r\n        \"THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\"\r\n      );\r\n      return geometry;\r\n    }\r\n  }\r\n\r\n  //\r\n\r\n  const numberOfTriangles = index.count - 2;\r\n  const newIndices = [];\r\n\r\n  if (drawMode === TriangleFanDrawMode) {\r\n    // gl.TRIANGLE_FAN\r\n\r\n    for (let i = 1; i <= numberOfTriangles; i++) {\r\n      newIndices.push(index.getX(0));\r\n      newIndices.push(index.getX(i));\r\n      newIndices.push(index.getX(i + 1));\r\n    }\r\n  } else {\r\n    // gl.TRIANGLE_STRIP\r\n\r\n    for (let i = 0; i < numberOfTriangles; i++) {\r\n      if (i % 2 === 0) {\r\n        newIndices.push(index.getX(i));\r\n        newIndices.push(index.getX(i + 1));\r\n        newIndices.push(index.getX(i + 2));\r\n      } else {\r\n        newIndices.push(index.getX(i + 2));\r\n        newIndices.push(index.getX(i + 1));\r\n        newIndices.push(index.getX(i));\r\n      }\r\n    }\r\n  }\r\n\r\n  if (newIndices.length / 3 !== numberOfTriangles) {\r\n    console.error(\r\n      \"THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\"\r\n    );\r\n  }\r\n\r\n  // build final geometry\r\n\r\n  const newGeometry = geometry.clone();\r\n  newGeometry.setIndex(newIndices);\r\n\r\n  return newGeometry;\r\n}\r\n\r\nexport { GLTFLoader };\r\n","import * as THREE from \"three\";\r\nimport { GLTFLoader } from \"./helpers/GLTFLoader\";\r\nimport { BufferGeometry, LoadingManager, Mesh, MeshToonMaterial, SpotLight } from \"three\";\r\n\r\nexport function Head() {\r\n  let container, loader;\r\n\r\n  let camera, scene, renderer;\r\n\r\n  let mesh: Mesh<BufferGeometry, MeshToonMaterial>;\r\n\r\n  let spotLight: SpotLight;\r\n\r\n  let mouseX = 0;\r\n  let mouseY = 0;\r\n\r\n  let targetX = 0;\r\n  let targetY = 0;\r\n\r\n  const windowHalfX = window.innerWidth / 2;\r\n  const windowHalfY = window.innerHeight / 2;\r\n\r\n  init();\r\n  animate();\r\n\r\n  function init() {\r\n    container = document.getElementById(\"root\");\r\n\r\n    //\r\n\r\n    camera = new THREE.PerspectiveCamera(\r\n      27,\r\n      window.innerWidth / window.innerHeight,\r\n      1,\r\n      10000\r\n    );\r\n    camera.position.z = 1200;\r\n\r\n    scene = new THREE.Scene();\r\n    scene.background = new THREE.Color(0x060708);\r\n\r\n    // LIGHTS\r\n\r\n    scene.add(new THREE.HemisphereLight(0x443333, 0x111122));\r\n\r\n    spotLight = new THREE.SpotLight(0xffffbb, 2);\r\n    spotLight.position.set(0.5, 1, 1);\r\n    spotLight.position.multiplyScalar(700);\r\n    scene.add(spotLight);\r\n\r\n    spotLight.castShadow = true;\r\n\r\n    spotLight.shadow.mapSize.width = 2048;\r\n    spotLight.shadow.mapSize.height = 2048;\r\n\r\n    spotLight.shadow.camera.near = 200;\r\n    spotLight.shadow.camera.far = 1500;\r\n\r\n    spotLight.shadow.camera.fov = 40;\r\n\r\n    spotLight.shadow.bias = -0.005;\r\n\r\n    //\r\n\r\n    const mapHeight = new THREE.TextureLoader().load(\r\n      \"./assets/Infinite-Level_02_Disp_NoSmoothUV-4096.jpg\"\r\n    );\r\n\r\n    const material = new THREE.MeshToonMaterial({\r\n      color: 0x552811,\r\n      // specular: 0x222222,\r\n      // shininess: 10,\r\n      bumpMap: mapHeight,\r\n      bumpScale: 12,\r\n    });\r\n\r\n    loader = new GLTFLoader(new LoadingManager());\r\n    loader.load(\"./assets/LeePerrySmith.glb\", function (gltf) {\r\n      createScene(gltf.scene.children[0].geometry, 100, material);\r\n    });\r\n\r\n    renderer = new THREE.WebGLRenderer();\r\n    renderer.setPixelRatio(window.devicePixelRatio);\r\n    renderer.setSize(window.innerWidth, window.innerHeight);\r\n    container.appendChild(renderer.domElement);\r\n\r\n    renderer.shadowMap.enabled = true;\r\n    renderer.outputEncoding = THREE.sRGBEncoding;\r\n\r\n    // EVENTS\r\n\r\n    document.addEventListener(\"mousemove\", onDocumentMouseMove);\r\n    window.addEventListener(\"resize\", onWindowResize);\r\n  }\r\n\r\n  function createScene(geometry, scale, material) {\r\n    mesh = new THREE.Mesh(geometry, material);\r\n\r\n    mesh.position.y = -50;\r\n    mesh.scale.set(scale, scale, scale);\r\n\r\n    mesh.castShadow = true;\r\n    mesh.receiveShadow = true;\r\n\r\n    scene.add(mesh);\r\n  }\r\n\r\n  //\r\n\r\n  function onWindowResize() {\r\n    renderer.setSize(window.innerWidth, window.innerHeight);\r\n\r\n    camera.aspect = window.innerWidth / window.innerHeight;\r\n    camera.updateProjectionMatrix();\r\n  }\r\n\r\n  function onDocumentMouseMove(event) {\r\n    mouseX = event.clientX - windowHalfX;\r\n    mouseY = event.clientY - windowHalfY;\r\n  }\r\n\r\n  //\r\n\r\n  function animate() {\r\n    requestAnimationFrame(animate);\r\n\r\n    render();\r\n  }\r\n\r\n  function render() {\r\n    targetX = mouseX * 0.001;\r\n    targetY = mouseY * 0.001;\r\n\r\n    if (mesh) {\r\n      mesh.rotation.y += 0.5 * (targetX - mesh.rotation.y);\r\n      mesh.rotation.x += 0.5 * (targetY - mesh.rotation.x);\r\n      mesh.material.color.setScalar(targetX + targetY );\r\n    }\r\n\r\n    \r\n\r\n    renderer.render(scene, camera);\r\n  }\r\n}\r\n","import React, { useEffect } from \"react\";\nimport logo from \"./logo.svg\";\nimport * as THREE from \"three\";\nimport \"./App.css\";\nimport { Head } from \"./Head\";\n\nfunction App() {\n  useEffect(() => {\n    Head();\n  }, []);\n\n  return <div className=\"App\"></div>;\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}